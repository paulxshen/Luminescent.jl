{"version":"1","records":[{"hierarchy":{"lvl1":"Features"},"type":"lvl1","url":"/features","position":0},{"hierarchy":{"lvl1":"Features"},"content":"Fully differentiable and GPU-accelerated finite difference time domain (FDTD) solver for full wave electromagnetic simulation and inverse design of photonic and RF devices.\n\nPowerful\n\nGenerative inverse design and simulation in just few lines of Python code!\n\nBroadband and multimode S-parameters\n\nEmbedded mode solver for modal sources and monitors\n\n.gds and gdsfactory integration\n\n.stl / .step  3D geometry import\n\nSmart\n\nFully differentiable (native automatic differentiation in Julia)\n\nSimultaneous inverse design of multiple 2D and 3D structures\n\nLength scale controlled geometry optimizer with fabrication constraints\n\nFast\n\nGPU acceleration on NVIDIA, AMD, and Apple Silicon\n\nAdaptive graded mesh reduces cell count\n\nTensor subpixel smoothing boosts accuracy\n\nComprehensive\n\nModal sources, plane waves, Gaussian beams, custom sources\n\nOblique sources and monitors\n\nPML, periodic, PEC, PMC boundaries\n\nNear and far field radiation patterns\n\nNonlinear, dispersive and anisotropic materials","type":"content","url":"/features","position":1},{"hierarchy":{"lvl1":"Features","lvl2":"Aboout"},"type":"lvl2","url":"/features#aboout","position":2},{"hierarchy":{"lvl1":"Features","lvl2":"Aboout"},"content":"We’re Stanford alum and founded Luminescent AI in 2024 to democratize photonic and RF design with AI.\n\nLinkedIn: follow us for product updates and opportunities!\n\nCompany: learn more about our mission and team!Email: \n\npaul@luminescentai​.comWhatsApp and WeChat: +1 (650) 776-7724","type":"content","url":"/features#aboout","position":3},{"hierarchy":{"lvl1":"Home"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Home"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"type":"lvl2","url":"/#overview","position":2},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"content":"Luminescent AI harnesses physics grounded AI for designing electromagnetic structures in photonics and RF. We offer Lumi FDTD for full wave simulations and inverse design, and Lumi Photonic PDK of inverse designed photonic components.","type":"content","url":"/#overview","position":3},{"hierarchy":{"lvl1":"Home","lvl2":"Aboout"},"type":"lvl2","url":"/#aboout","position":4},{"hierarchy":{"lvl1":"Home","lvl2":"Aboout"},"content":"We’re Stanford alum and founded Luminescent AI in 2025 to democratize photonic and RF design with AI.\n\nLinkedIn: follow us for updates and opportunities!\n\nWebsite\nEmail: \n\npaul@luminescentai​.comWhatsApp and WeChat: +1 (650) 776-7724","type":"content","url":"/#aboout","position":5},{"hierarchy":{"lvl1":"Installation"},"type":"lvl1","url":"/install","position":0},{"hierarchy":{"lvl1":"Installation"},"content":"Please fill out \n\nnew user form to obtain install scripts for unrestricted simulation. Doesn’t include inverse design.\n\nHoliday notice: Luminescent Community Cluster will come online on 01-12","type":"content","url":"/install","position":1},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 1: Luminescent Community Cluster (free and public)"},"type":"lvl2","url":"/install#option-1-luminescent-community-cluster-free-and-public","position":2},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 1: Luminescent Community Cluster (free and public)"},"content":"Run on our latest Nvidia Blackwell GPUs for free! Just \n\nregister (allow 1 business day for processing) and install our python frontend via pip install luminescent. Then see our simulation tutorials. All your jobs on the community cluster are publicly visible. If you want a private and secured environment, please upgrade to an enterprise cluster.","type":"content","url":"/install#option-1-luminescent-community-cluster-free-and-public","position":3},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 2: Luminescent Enterprise Cluster (private and secure)"},"type":"lvl2","url":"/install#option-2-luminescent-enterprise-cluster-private-and-secure","position":4},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 2: Luminescent Enterprise Cluster (private and secure)"},"content":"Similar to community cluster but private and secured for your organization. Comes with premium support and consulting. Pricing is a fixed annual fee plus $3 per GPU hour (similar to raw rates on GCP or AWS). Sign up via \n\ninfo@luminescentai​.com","type":"content","url":"/install#option-2-luminescent-enterprise-cluster-private-and-secure","position":5},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 3: Local Installation"},"type":"lvl2","url":"/install#option-3-local-installation","position":6},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 3: Local Installation"},"content":"Customers of Enterprise Cluster are also entitled to local installation binaries upon request.","type":"content","url":"/install#option-3-local-installation","position":7},{"hierarchy":{"lvl1":"Photonic PDK"},"type":"lvl1","url":"/pdk","position":0},{"hierarchy":{"lvl1":"Photonic PDK"},"content":"Lumi Photonic PDK (process design kit) is a library of AI inverse designed photonic components for PIC (photonic integrated circuit). Unlike a traditional PDK, each component here is more akin to a reference design that shows what’s possible. In most cases, they should be re-optimized for your specific needs and process node.","type":"content","url":"/pdk","position":1},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Available components"},"type":"lvl2","url":"/pdk#available-components","position":2},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Available components"},"content":"Updating... Please check back mid January\n\nPerfectly vertical grating coupler\n","type":"content","url":"/pdk#available-components","position":3},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"type":"lvl1","url":"/test-fss","position":0},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"content":"","type":"content","url":"/test-fss","position":1},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"type":"lvl2","url":"/test-fss#overview","position":2},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"content":"We simulate microwave frequency selective surface (FSS) with 12GHz bandstop. periodic Metal cross array on dielectric substrate. Compare with Tidy3D example \n\nhttps://​www​.flexcompute​.com​/tidy3d​/examples​/notebooks​/MicrowaveFrequencySelectiveSurface\n\n","type":"content","url":"/test-fss#overview","position":3},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"type":"lvl2","url":"/test-fss#geometry","position":4},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport math\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# simulation folder\nstudy='microwave_frequency_selective_surface'\npath = os.path.join('studies', study)\n\n# length and frequency units are arbitrary\nfrequency = 12  # origin frequency GHz\nbw = 4  # bandwidth\ndf = 0.05  # frequency step\nwl1f = 300  # vacuum wavelength at 1 unit of frequency in your units\nwl = wl1f / frequency  # characteristic wavelength\nfrequencies = np.linspace(frequency-bw/2, frequency+bw/2, round(bw/df+1))\n\n# unit cell [mm]\nP = 15  # periodicity\nL = 9.4  # length of cross\nW = 2.0  # width of cross stub\nd = 2.2  # height of substrate\nth = 0.1  # metal thickness\ngap = 30.0  # air gap below and above - keeps resonant evanescent field from coupling to lossy PML\nmargin = 2.0\n\n# adaptive meshing\ndx=W/5  # desired spatial resolution\nnres = 16\ndx0 = wl / nres\nmesh_density = dx0 /dx\n\n# material_library\nmaterial_library = lumi.MATERIAL_LIBRARY\nmaterial_library[\"sub\"] = lumi.Material(epsilon=2.5, mesh_density=mesh_density)\nmaterial_library[\"PEC\"] = lumi.PECMaterial(mesh_density=mesh_density)\n\n# make geometry in gdsfactory. 1/4 section of unit cell due to symmetry\n# alternatively can import .gds into gdsfactory\n\nWG = (1, 0)\nBBOX = (2, 0)\n\nlayer_stack = LayerStack(\n    layers={\n        \"WG\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=th,\n            zmin=0,\n            material=\"PEC\",\n            mesh_order=1,\n        ),\n        \"sub\": LayerLevel(\n            layer=LogicalLayer(layer=BBOX),\n            thickness=d,\n            zmin=-d,\n            material=\"sub\",\n            mesh_order=2,\n        ),\n    }\n)\n\nc = gf.Component()\nc.add_polygon(\n    [(0, 0), (0, L / 2), (W / 2, L / 2), (W / 2, 0)],\n    layer=WG,\n)\np = c.add_polygon(\n    [(W / 2, W / 2), (W / 2, 0), (L / 2, 0), (L / 2, W / 2)],\n    layer=WG,\n)\nc.add_polygon([(0, 0), (0, P / 2), (P / 2, P / 2), (P / 2, 0)], layer=BBOX)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-fss#geometry","position":5},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Problem"},"type":"lvl2","url":"/test-fss#problem","position":6},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Problem"},"content":"\n\nxc = P / 4\nyc = P / 4\nports = [\n    lumi.PlanePort(\n        name='o1',\n        origin=[xc, yc, th + gap],\n        frame=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n    ),\n    lumi.PlanePort(\n        name='o2',\n        origin=[xc, yc, -d- gap],\n        frame=[[-1, 0, 0], [0, 1, 0], [0, 0, -1]],\n    ),\n]\n\nnx=ny=round(P/2/dx)\na=np.ones((nx,ny))\nmodes = [lumi.Mode(\n    frequencies=[frequency],\n    fields=[[{\"Ex\": a, \"Hy\": a},{\"Ey\": a, \"Hx\": -a}]],\n    start=[-P/4, -P/4],\n    stop=[P/4, P/4],\n    )]\n\nsources = [lumi.Source(\"o1\", source_port_margin=margin, frequency=frequency, bandwidth=bw)]\n\nviews=[lumi.View('Ex',x=0,y=0,z=th/2)]\n\n# Luminescent community cluster client\nemail=____# replace with your registered email\nclient=lumi.Client(email,cluster='luminescent_community_cluster')\n\nlumi.make(\n    path,\n    component=c,\n    frequencies=frequencies,\n    wl1f=wl1f,\n    # antisymmetric/PEC/odd vs symmetric/PMC/even symmetry\n    boundaries=[\"PEC\", \"PMC\", \"PML\"],\n    #\n    sources=sources,\n    ports=ports,\n    modes=modes,\n    zmin=-gap-d,\n    zmax= th + gap + margin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    nres=nres,\n    tmax=50,  # max time [periods]\n    energy_decay_threshold=0.001,  # field decay threshold for stopping simulation\n    saveat=1,\n    # visualization\n    views=views,\n    # \n    client=client,\n)\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-fss#problem","position":7},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Movie"},"type":"lvl2","url":"/test-fss#movie","position":8},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Movie"},"content":"\n\nlumi.movie(path)\n\n\n\n\n\n","type":"content","url":"/test-fss#movie","position":9},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"type":"lvl2","url":"/test-fss#analysis","position":10},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = [10 * math.log10(x) for x in lumi.query(sol,'T2,1')]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n","type":"content","url":"/test-fss#analysis","position":11},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"type":"lvl1","url":"/test-ring","position":0},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"content":"","type":"content","url":"/test-ring","position":1},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"type":"lvl2","url":"/test-ring#overview","position":2},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"content":"We simulate small silicon ring resonator coupled to parallel waveguides buried in silica cladding. We use midplane z PMC symmetry to slash cell count by half.\n\n","type":"content","url":"/test-ring#overview","position":3},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"type":"lvl2","url":"/test-ring#geometry","position":4},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# simulation folder \nstudy='photonic_ring_resonator'\npath = os.path.join('studies', study)\n\n# length units are arbitrary so long as they are consistent, in this case [um]. everything gets normalized around origin wavelength and period at backend.\nwavelength = 1.55  # characteristic wavelength [um]\nbandwidth = 0.1  # wavelength bandwidth [um]\nwavelengths = np.linspace(wavelength - bandwidth / 2, wavelength + bandwidth / 2, 401)\n\nr = 3.1  # radius of ring\nw_wg = 0.4  # width of waveguide\ngap = 0.1  # gap between waveguide and ring\nh_wg = 0.18  # h_wg of waveguide\n\n# gds layers\nWG = (1, 0)  # waveguide layer\nBBOX = (10, 0)  # bounding box layer\n\n# we create geometry in gdsfactory. alternatively, you can import .gds layout into gdsfactory or .stl bodies directly into ours\n\n# margins\nheight_port_margin = lateral_port_margin = 0.8\nmargin = 1.2 * lateral_port_margin\nzmargin = 1.2 * height_port_margin\nsource_port_margin = 1.0 * (w_wg + 2 * lateral_port_margin)\n\n# draw layout in gdsfactory. `gf.components` defaults to layer WG = (1, 0)\nc = gf.Component()\n\ndut = c << gf.components.ring(radius=r, width=w_wg, layer=WG)\n\nl_branch = 2 * r + w_wg + source_port_margin + 2*margin\nxoffset = -source_port_margin - margin - r - w_wg / 2\nyoffset = w_wg + gap + r\nbranch_top = c << gf.components.straight(length=l_branch, width=w_wg)\nbranch_top.move((xoffset, w_wg + gap + r))\n\nbranch_bottom_left = c << gf.components.straight(length=source_port_margin, width=w_wg)\nbranch_bottom_left.move((xoffset, -yoffset))\n\nbranch_bottom_right = c << gf.components.straight(length=l_branch - source_port_margin, width=w_wg)\nbranch_bottom_right.connect(\"o1\", branch_bottom_left.ports[\"o2\"])\n\n\n# add ports\nc.add_port(\"o1\", port=branch_bottom_right.ports[\"o1\"])\nc.add_port(\"o2\", port=branch_bottom_right.ports[\"o2\"])  # thru channel\nc.add_port(\"o3\", port=branch_top.ports[\"o1\"])  # drop channel\n\nc << gf.components.bbox(component=c, layer=BBOX, top=margin, bottom=margin)\nc.plot()\n\n\n\n","type":"content","url":"/test-ring#geometry","position":5},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"type":"lvl2","url":"/test-ring#solve","position":6},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"content":"\n\n# for gdsfactory, we need vertical layer stack. \"core\" layer is special as `height_port_margin` are demarcated from it for defining modal sources and monitors. during 3d meshing lower mesh order layers supplant higher mesh order layers\nlayer_stack = LayerStack(\n    layers={\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=h_wg/2,\n            zmin=0.0,\n            material=\"Si\",\n            mesh_order=10,\n        ),\n    }\n)\n\n# our default lumi.MATERIAL_LIBRARY lib covers limited range of photonic and PCB material_library. here we create our own material_library. `background` is special and tags regions outside any bodies during meshing\nmaterial_library = {\n    \"Si\": lumi.Material(epsilon=12.25),\n    \"SiO2\": lumi.Material(epsilon=2.25),\n}\nmaterial_library[\"background\"] = material_library[\n    \"SiO2\"\n]  \n\n# source launches `source_port_margin` in front of port. it's bidirectional: the other direction goes into PML. pulse spectrum rolls off gradually past bandwidth limits.\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n        wavelength=wavelength,\n        bandwidth=wavelength/5,\n        modenums=[0],  # fundamental mode only\n    )\n]\n\nlx = w_wg + 2 * lateral_port_margin\nly = h_wg + 2 * height_port_margin\nmodes = [\n    lumi.Mode(\n        wavelengths=np.linspace(wavelengths[0], wavelengths[-1],5),\n        start=[-lx / 2, 0],  # local xy frame\n        stop=[lx / 2, h_wg/2 + height_port_margin],\n        boundaries=['PML',('PMC','PML')]\n    )\n]\n\n# Luminescent community cluster client\nemail=____ # replace with your registered email\nclient=lumi.Client(email,cluster='luminescent_community_cluster')\n\nlumi.make(\n    path=path,\n    component=c,\n    wavelengths=wavelengths,\n    sources=sources,\n    modes=modes,\n    # limits\n    boundaries=['PML','PML',('PMC','PML')], # z midplane PMC symmetry\n    zmin=0,\n    zmax=h_wg/2 + zmargin,\n    # materials and layers\n    material_library=material_library,\n    layer_stack=layer_stack,\n    # accuracy and speed settings\n    nres=8,  # number of grid points per wavelength in material (not vacuum)\n    relative_courant=0.95,  # relative to maximum theoretical Courant number at\n    relative_pml_depths=[1, 1, 0.25],  \n    tmax=1000,  # max time [periods]\n    energy_decay_threshold=0.001,  # field energy decay threshold for stopping simulation\n    saveat=50,  # save and plot field every _ periods, involves slow disk write\n    # visualization\n    views=[lumi.View(\"Hz\",x=0,y=0,z=0)],\n    # \n    client=client,\n)\n\n\n\n\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-ring#solve","position":7},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"type":"lvl2","url":"/test-ring#visualize","position":8},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"content":"\n\nlumi.movie(path) # full movie - this may take a while to generate\n\n\n\n\n\n","type":"content","url":"/test-ring#visualize","position":9},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"type":"lvl2","url":"/test-ring#analysis","position":10},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = wavelengths\n\n# S or T params. wavelength or frequency ordered depending on problem setup\ny = lumi.query(sol, \"To3@0,o1@0\")  # same as y=np.abs2(sol['waves']['o3@0+']/sol['waves']['o1@0-'])\n# y = lumi.query(sol, \"T3,1\") # flux\n\nplt.plot(x, y)\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"drop channel transmitted power\")\nplt.show()\n\n\n\n","type":"content","url":"/test-ring#analysis","position":11},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"type":"lvl1","url":"/test-stub","position":0},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"content":"","type":"content","url":"/test-stub","position":1},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"type":"lvl2","url":"/test-stub#overview","position":2},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"content":"We simulate a quarter wave stub bandstop filter in RF microstrip with nominal 5GHz notch.\n\n","type":"content","url":"/test-stub#overview","position":3},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"type":"lvl2","url":"/test-stub#geometry","position":4},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# simulation folder \nstudy='microstrip_stub_filter'\npath = os.path.join('studies', study)\n\n# length and frequency units are arbitrary but must be consistent. here we use mm and GHz\nfrequency = 5  # characteristic frequency in GHz\nfrequencies = np.linspace(3, 7, 81).tolist()\nwl1f = 300  # vacuum wavelength at 1 unit of frequency, all in your units\nwavelength = wl1f / frequency  # characteristic wavelength\nbandwidth = max(frequencies) - min(frequencies)\n\n# microstrip\nw_line = 1.52  # mm\nth = 0.035  # mm\nd = 0.8  # mm\nc = 87.5 / 139  # relative signal speed, from microstrip calculator\n\nwl_sig = wl1f * c / frequency  # wavelength in the signal line\nl_stub = wl_sig / 4 # quarter-wave stub length\nl_feed = 1 * l_stub\nlateral_port_margin = height_port_margin = 2 * d\nmargin = zmargin = 1.25 * lateral_port_margin\nlx_mode = w_line + 2 * lateral_port_margin  # lateral size of mode region\nsource_port_margin = 1.5 * (w_line + 2 * lateral_port_margin)\n\n# layers\nFEED = 1, 0\nSTUB = 2, 0\nSUB = 10, 0\n\n# make geometry in gdsfadory\n# alternatively can import .gds into gdsfadory\nc = gf.Component()\nfeed = c << lumi.straight(length=l_feed, width=w_line, layer=FEED)\nstub = c << lumi.straight(length=l_stub, width=w_line, layer=STUB)\nstub.rotate(90)\nstub.movex(l_feed / 2)\next = c << lumi.straight(source_port_margin, width=w_line, layer=FEED)\next.connect(\"o2\", feed.ports[\"o1\"])\n\nfor i in (1, 2):\n    c.add_port(f\"o{i}\", port=feed.ports[f\"o{i}\"])\n\nc << gf.components.bbox(component=c, layer=SUB, top=margin, bottom=margin)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-stub#geometry","position":5},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"type":"lvl2","url":"/test-stub#solve","position":6},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"content":"\n\n# adaptive meshing\nnres = 16\ndx0 = wavelength / nres\n\nlayer_stack = LayerStack(\n    layers={\n        \"feed\": LayerLevel(\n            layer=LogicalLayer(layer=FEED),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=10,\n        ),\n        \"stub\": LayerLevel(\n            layer=LogicalLayer(layer=STUB),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=20,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=SUB),\n            zmin=-d,\n            thickness=d,\n            material=\"sub\",\n            mesh_order=30,\n        ),\n    }\n)\n\n# materials\neps_sub = 4.3\nn_sub = np.sqrt(eps_sub)\n\ndx = w_line / 4  # 4 mesh points across the strip\nn_PEC = dx0 / (dx)  # mesh density relative to vacuum\n\nmaterial_library = {\n    \"sub\": lumi.Material(epsilon=eps_sub),\n    \"PEC\": lumi.PECMaterial(mesh_density=n_PEC),\n}\nmaterial_library[\"background\"] = lumi.Material(epsilon=1.0)\n\n_dx=dx \n_dy=th\nmodes = [\n    lumi.Mode(\n        ports=[\"o1\", \"o2\"],\n        frequencies=[frequency],\n        metallic_boundaries=[\"y-\", \"feed\"],\n        nmodes=1,\n        start=[-lx_mode/2, -d], # local xy frame, local y=0 at global zmin of port layer\n        stop=[lx_mode/2, th + height_port_margin],\n        voltage_line=[(0, -d), (0, 0)], # optional\n        current_loop=[\n            (-w_line / 2 - _dx,  - _dy),\n            (-w_line / 2 - _dx,  th + _dy),\n            (w_line / 2 + _dx,  th + _dy),\n            (w_line / 2 + _dx,  - _dy),\n        ], # optional\n    )\n]\n\nsources = [\n    lumi.Source(\n        \"o1\", frequency=frequency, duration=0.5, source_port_margin=source_port_margin\n    ) # modulated Gaussian pulse\n]\n\nviews=[\n        lumi.View(\"Ez\", x=-source_port_margin, y=0, z=-d / 2),\n        lumi.View(\"Hz\", z=th / 2),\n    ]\n \n# Luminescent community cluster client\nemail=____# replace with your registered email\nclient=lumi.Client(email,cluster='luminescent_community_cluster')\n\nlumi.make(\n    path=path,\n    component=c,\n    frequency=frequency, # characteristic frequency\n    frequencies=frequencies,\n    wl1f=wl1f,\n    sources=sources,\n    modes=modes,\n    # bounds\n    boundaries=[\"PML\", \"PML\", [\"PEC\", \"PML\"]],\n    zmin=-d,\n    zmax=th + zmargin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    # performance\n    nres=nres,\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    relative_pml_depths=[1, 0.3, 0.3],\n    energy_decay_threshold=0.01,  # field decay threshold for stopping simulation\n    saveat=1,  # save frame for plotting every _ periods\n    # visualization\n    views=views,\n    # \n    client=client,\n)\n\n\n\n\n\n\n\n\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-stub#solve","position":7},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"type":"lvl2","url":"/test-stub#visualize","position":8},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"content":"\n\nlumi.movie(path)\n\n\n\n\n\n","type":"content","url":"/test-stub#visualize","position":9},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"type":"lvl2","url":"/test-stub#analysis","position":10},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = lumi.query(sol, \"To2,o1\") # convenience function for T-parameters using modal decomposition\n\n# S-parameters can also be computed explicitly from complex valued modal or voltage waves:\n# y = np.abs2(sol[\"waves\"][\"o2@0+\"] / sol[\"waves\"][\"o1@0-\"]) # explicit T21 using forward/backward modal amplitudes\n# y = np.abs2(sol[\"waves\"][\"o2+\"] / sol[\"waves\"][\"o1-\"]) # using forward/backward voltage waves\n\ny = [10 * np.log10(v) for v in y]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n\n\ny=377*sol['Z']['o1']\nplt.plot(x,np.real(y),label=\"Real\",color='orange')\nplt.plot(x,np.imag(y),label=\"Imaginary\",color='blue')\nplt.xlabel(\"f [GHz]\")\nplt.ylabel('complex line impedance [Ohms]')\nplt.legend()\nplt.show()\n\n","type":"content","url":"/test-stub#analysis","position":11}]}