{"version":3,"kind":"Notebook","sha256":"dfd4f29def6e382509d7ebccf7bd8d3be56a4982486c9bac8a1ddaebeb615d1d","slug":"opt-pvgc","location":"/opt_PVGC.ipynb","dependencies":[],"frontmatter":{"title":"Inverse design of perfectly vertical photonic (meta)grating coupler","content_includes_title":false,"kernelspec":{"name":"python3","display_name":"base","language":"python"},"numbering":{"title":{"offset":2}},"exports":[{"format":"ipynb","filename":"opt_PVGC.ipynb","url":"/build/opt_PVGC-65ebbd2de0b2c6a7b73855a7ce0cd4f4.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Geometry","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"rD0TVGZlCf"}],"identifier":"geometry","label":"Geometry","html_id":"geometry","implicit":true,"key":"W2ZLGnumGK"}],"key":"fZf9BdC6J4"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import math\nimport os\nimport matplotlib.pyplot as plt\nimport luminescent as lumi\nimport gdsfactory as gf\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport numpy as np\nfrom IPython.display import Image, display\n\npath = os.path.join(\"studies\", \"metagrating_coupler\")\nwl = 1.55  # um\nbw = 0.02\nwavelengths = [wl - bw / 2, wl, wl + bw / 2]  # um\n\nmaterial_library = lumi.MATERIAL_LIBRARY\nmaterial_library[\"background\"] = material_library[\"SiO2\"]  # set background material\nnSi = math.sqrt(material_library[\"Si\"][\"epsilon\"])\nnox = math.sqrt(material_library[\"SiO2\"][\"epsilon\"])\n\nw = 0.5  # gaussian beam waist\nR = 1.0 * w  # source radius\nwidth = 10  # of design region\nlength = 1.5 * width  # of design region\nw_wg = 0.5\nl_wg = 2 * w_wg\ndz = 0.1\n\n# margins\nlateral_port_margin = height_port_margin = 0.3\nxmargin = 1.5 * lateral_port_margin\nzmargin = 1.5 * height_port_margin\nbox_thickness = 0.5\nsource_port_margin = 1.5 * dz\n\nWG = 1, 0\nTEETH = 2, 0\nBBOX = 4, 0\nDESIGN = 100, 0\n\n# makes gdsfadory component to be optimized. has rectangular design region with port stubs. ports numbered clockwise from bottom left.\nc = gf.Component()\ndut = c << lumi.mimo(\n    length,\n    width,\n    w_wg=w_wg,\n    l_wg=l_wg,\n    west=1,\n    layer_wg=WG,\n    layer_design=DESIGN,\n    init=1,\n)\n\nxoffset = -(length - width + width / 2)\nyoffset = -(width / 2)\ndut.movex(xoffset)\ndut.movey(yoffset)\nc.add_port(\"o2\", port=dut.ports[\"o1\"])\n\nc << gf.components.bbox(\n    component=c, layer=BBOX, top=xmargin, bottom=xmargin, right=xmargin\n)\nc.plot()\n","key":"MuHWyKT2FB"},{"type":"outputs","id":"qF8HgXuLBZl0kdlpM8O4R","children":[{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"running luminescent python frontend\n"},"children":[],"key":"G7eCgdzXnk"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"ffa11690c0b4378cfbde14038fd2c102","path":"/build/ffa11690c0b4378cfbde14038fd2c102.png"},"text/plain":{"content":"<Figure size 800x600 with 1 Axes>","content_type":"text/plain"}}},"children":[],"key":"JczfCqOKn0"}],"key":"xzBwvnekxg"}],"key":"yK1yRIm3Vx"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Solve","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"oNDCWtCk8I"}],"identifier":"solve","label":"Solve","html_id":"solve","implicit":true,"key":"bge1PJlxXW"}],"key":"S1FTQ5jMES"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# layer stack. lower mesh order layers override higher mesh order layers. for 2.5D problems as is here, the mesher will slice thru middle of 'core' layer\nthickness_teeth = 0.07\nthickness_slab = 0.15\nthickness = thickness_teeth + thickness_slab\nlayer_stack = LayerStack(\n    layers={\n        \"design\": LayerLevel(\n            layer=LogicalLayer(layer=DESIGN),\n            zmin=thickness_slab,\n            thickness=thickness_teeth,\n            material=\"design\",\n            mesh_order=0,\n        ),\n        \"teeth\": LayerLevel(\n            layer=LogicalLayer(layer=TEETH),\n            zmin=thickness_slab,\n            thickness=thickness_teeth,\n            material=\"Si\",\n            mesh_order=1,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            zmin=0,\n            thickness=thickness,\n            material=\"Si\",\n            mesh_order=3,\n        ),\n    }\n)\n\n# make fiber mode\nnx = 2 * round(R / 0.05)\n_dx = 2 * R / nx\nx = np.linspace(-R + _dx / 2, R - _dx / 2, nx)\ny = np.linspace(-R + _dx / 2, R - _dx / 2, nx)\nX, Y = np.meshgrid(x, y)\ng = np.exp(-(X**2 + Y**2) / (2 * w**2))\n\nmodes = [\n    lumi.Mode(ports=[\"o1\"], fields={\"Ey\": g, \"Hx\": -nox * g}, dx=_dx),\n    lumi.Mode(ports=[\"o2\"]),\n]\n\n# additional ports not attached to gdsfactory component\nports = [\n    lumi.PlanePort(\n        name=\"o1\",\n        origin=[0, 0, thickness + dz],\n        frame=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n        length=2 * R,\n        width=2 * R,\n    )\n]\n\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n    )\n]\n\n# optimization targets of T params. o1@0 means optical port 1 on mode 0 (fundamental mode)\ntargets = [\n    lumi.Target(\"To2@0,o1@0\", 1.0, weight=1 / len(wavelengths), wavelength=x)\n    for x in wavelengths\n]\n\ntmax = (\n    1.0\n    * (length + width / 2 + 2 * box_thickness + zmargin + 2 * thickness + l_wg)\n    / wl\n    * nSi\n    + 5\n)  # max time [periods]\n\ndesigns = [\n    lumi.Design(\n        \"d1\",\n        layer=DESIGN,\n        lmin=0.2,\n        fill_material=\"Si\",\n        void_material=\"SiO2\",\n        symmetries=[\"y\"],\n        uniform_along=\"z\",\n    )\n]\noptimizer = lumi.Optimizer(\n    stoploss=0.2,\n    area_change=0.03,  # area change initial target\n    iters=20,  # max iters\n)\n\nlumi.make(\n    #\n    path=path,  # path to make problem folder\n    component=c,\n    wavelengths=wavelengths,\n    ports=ports,\n    modes=modes,\n    sources=sources,\n    boundaries=[\"PML\", \"PML\", [\"PEC\", \"PML\"]],\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    lateral_port_margin=lateral_port_margin,\n    height_port_margin=height_port_margin,\n    zmin=-box_thickness,  # zmin of simulation region\n    zmax=thickness + zmargin,  # zmax of simulation region\n    #\n    gpu=\"CUDA\",\n    relative_courant=0.9,\n    nres=4,  # number of grid points per wavelength in material (not vacuum)\n    tmax=tmax,  # total simulation time in periods\n    relative_pml_depths=[[1, 0.3], 0.3, 1],  # relative PML thicknesses in x, y, z\n    #\n    saveat=10,  # save frame every `saveat` periods for movie\n    force=True,  # delete and overwrite existing path\n    #\n    show_field=\"Ey\",\n    show_grid=False,\n    field_slices=[0, 0, thickness_teeth / 2 + thickness_slab],\n    geometry_slices=[0, 0, thickness_teeth / 2 + thickness_slab],\n    # inverse design parameters\n    targets=targets,\n    designs=designs,\n    optimizer=optimizer,\n)\n# studies adjoint optimization.\nlumi.solve(path)\ndisplay(Image(filename=os.path.join(path, \"peak.gif\")))","key":"H1aQs5txP0"},{"type":"outputs","id":"tihi28wtPGHt5uwqDpkbk","children":[{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"fa6096a5fdad79023492ff461089c477","path":"/build/fa6096a5fdad79023492ff461089c477.png"},"text/plain":{"content":"<Figure size 640x480 with 6 Axes>","content_type":"text/plain"}}},"children":[],"key":"K8VIAqvO0p"},{"type":"output","jupyter_data":{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"387853494460beb665545821835a95f2","path":"/build/387853494460beb665545821835a95f2.png"},"text/plain":{"content":"<Figure size 640x480 with 6 Axes>","content_type":"text/plain"}}},"children":[],"key":"YhCFxK9zJG"},{"type":"output","jupyter_data":{"name":"stdout","output_type":"stream","text":"using simulation folder c:\\Users\\default.LAPTOP-HMRU58MH\\Desktop\\lumi\\luminescent\\studies\\metagrating_coupler\n"},"children":[],"key":"rmh7NQSNFT"},{"type":"output","jupyter_data":{"name":"stderr","output_type":"stream","text":"c:\\Users\\default.LAPTOP-HMRU58MH\\Desktop\\lumi\\luminescent\\luminescent\\sparams.py:127: UserWarning: Layer (200, 0) not found in component 'Unnamed_20' layers. [(1, 0), (4, 0), (100, 0)]\n  bbox = component.extract([layer]).bbox_np().tolist()\n"},"children":[],"key":"Z5oNNFot2r"},{"type":"output","jupyter_data":{"output_type":"execute_result","execution_count":9,"metadata":{},"data":{"text/plain":{"content":"0","content_type":"text/plain"}}},"children":[],"key":"CIqYxqFP2x"}],"key":"vGpobVCPk8"}],"key":"e3uOKyO6P2"}],"key":"o5JjE3joAX"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Inverse design of photonic wavelength division demultiplexer","url":"/opt-demux","group":"Inverse design tutorials"},"next":{"title":"Simulation","url":"/sim","group":"Guide"}}},"domain":"http://localhost:3004"}