{"version":"1","records":[{"hierarchy":{"lvl1":"Features"},"type":"lvl1","url":"/features","position":0},{"hierarchy":{"lvl1":"Features"},"content":"Fully differentiable and GPU-accelerated finite difference time domain (FDTD) engine for full wave electromagnetic simulation and inverse design.\n\nPowerful\n\nGenerative inverse design and simulation in just few lines of Python code!\n\nBroadband and multimode S-parameters\n\nEmbedded mode solver for modal sources and monitors\n\n.gds and gdsfactory integration\n\n.stl / .step  3D geometry import\n\nSmart\n\nFully differentiable (native automatic differentiation in Julia)\n\nSimultaneous inverse design of multiple 2D and 3D structures\n\nLength scale controlled geometry optimizer with fabrication constraints\n\nFast\n\nGPU acceleration on NVIDIA, AMD, and Apple Silicon\n\nAdaptive graded mesh reduces cell count\n\nTensor subpixel smoothing boosts accuracy\n\nComprehensive\n\nModal sources, plane waves, Gaussian beams, custom sources\n\nOblique sources and monitors\n\nPML, periodic, PEC, PMC boundaries\n\nNear and far field radiation patterns\n\nNonlinear, dispersive and anisotropic materials\n\nFig. Inverse designed broadband bidirectional perfectly vertical grating coupler (PVGC)","type":"content","url":"/features","position":1},{"hierarchy":{"lvl1":"Home"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Home"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"type":"lvl2","url":"/#overview","position":2},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"content":"Luminescent AI harnesses physics grounded AI for designing electromagnetic structures in photonics and RF. We offer Lumi FDTD for full wave simulations and inverse design, and Lumi Photonic PDK of inverse designed photonic components.\n\nFig. Inverse designed broadband bidirectional perfectly vertical grating coupler (PVGC)","type":"content","url":"/#overview","position":3},{"hierarchy":{"lvl1":"Home","lvl2":"About"},"type":"lvl2","url":"/#about","position":4},{"hierarchy":{"lvl1":"Home","lvl2":"About"},"content":"We’re Stanford alum and founded Luminescent AI in 2025 to democratize photonic and RF design with physics grounded AI.\n\nLinkedIn: follow us for updates and opportunities!\n\nWebsite\nEmail: \n\npaul@luminescentai​.comWhatsApp and WeChat: +1 (650) 776-7724","type":"content","url":"/#about","position":5},{"hierarchy":{"lvl1":"Installation"},"type":"lvl1","url":"/install","position":0},{"hierarchy":{"lvl1":"Installation"},"content":"","type":"content","url":"/install","position":1},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"type":"lvl2","url":"/install#option-1-luminescent-community-cloud-free-and-public","position":2},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"content":"Run on our latest Nvidia Blackwell GPUs for free! Just \n\nregister (allow 1 business day for processing) and install our python frontend client. Unlike before, no need to install the backend. See our simulation tutorials afterwards. Community cloud only supports simulations (not inverse design). Everything uploaded is publicly visible. If you want a private and secured environment, please upgrade to an enterprise cloud.","type":"content","url":"/install#option-1-luminescent-community-cloud-free-and-public","position":3},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1A: Frontend client on Google Colab","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"type":"lvl3","url":"/install#option-1a-frontend-client-on-google-colab","position":4},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1A: Frontend client on Google Colab","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"content":"pip install luminescent\n\nUnlike before, we’re only installing the python frontend client. This only takes a minute and the basic free CPU runtime is sufficient. See \n\nGoogle Colab example","type":"content","url":"/install#option-1a-frontend-client-on-google-colab","position":5},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1B: Frontend client on local machine","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"type":"lvl3","url":"/install#option-1b-frontend-client-on-local-machine","position":6},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1B: Frontend client on local machine","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"content":"Due to a issue with pymeshlab dependency, we currently only support Python 3.12 . If that’s your default python, do:\n\npip install luminescent\n\nIf you installed multiple Python versions, you can also explicitly do:\n\npath_to_python3.12 -m pip install luminescent (replace path_to_python3.12 with your actual python 3.12 path)\n\nSome systems can take few minutes to initialize dependencies on first run.","type":"content","url":"/install#option-1b-frontend-client-on-local-machine","position":7},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 2: Luminescent Enterprise cloud (private and secure)"},"type":"lvl2","url":"/install#option-2-luminescent-enterprise-cloud-private-and-secure","position":8},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 2: Luminescent Enterprise cloud (private and secure)"},"content":"Similar to community cloud but private and secured for your organization. Comes with premium support and consulting. Pricing is a fixed annual fee plus $3 per GPU hour (similar to raw rates on GCP or AWS). Sign up via \n\ninfo@luminescentai​.com","type":"content","url":"/install#option-2-luminescent-enterprise-cloud-private-and-secure","position":9},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 3: Local backend installation (advanced users)"},"type":"lvl2","url":"/install#option-3-local-backend-installation-advanced-users","position":10},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 3: Local backend installation (advanced users)"},"content":"Customers of Enterprise cloud are also entitled to local backend binaries upon request.","type":"content","url":"/install#option-3-local-backend-installation-advanced-users","position":11},{"hierarchy":{"lvl1":"Inverse Design"},"type":"lvl1","url":"/opt","position":0},{"hierarchy":{"lvl1":"Inverse Design"},"content":"","type":"content","url":"/opt","position":1},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Overview"},"type":"lvl2","url":"/opt#overview","position":2},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Overview"},"content":"Workflow same as simulation. Only difference is passing additional args to make : designs, targets, optimizer. solve then runs optimization loop instead of single simulation. Each iteration has forward and backward pass. Forward pass is a simulation that has to save all intermediate fields to compute gradients in backward pass. Each iteration is >5x slower than single simulation. >40 iterations typically needed to converge. Altogether >200x slower than single simulation.","type":"content","url":"/opt#overview","position":3},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Design regions"},"type":"lvl2","url":"/opt#design-regions","position":4},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Design regions"},"content":"   .. autofunction:: luminescent.opt.Design","type":"content","url":"/opt#design-regions","position":5},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Targets"},"type":"lvl2","url":"/opt#targets","position":6},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Targets"},"content":"   .. autofunction:: luminescent.opt.Target","type":"content","url":"/opt#targets","position":7},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Optimizer"},"type":"lvl2","url":"/opt#optimizer","position":8},{"hierarchy":{"lvl1":"Inverse Design","lvl2":"Optimizer"},"content":"    .. autofunction:: luminescent.opt.Optimizer","type":"content","url":"/opt#optimizer","position":9},{"hierarchy":{"lvl1":"Inverse design of perfectly vertical photonic (meta)grating coupler"},"type":"lvl1","url":"/opt-pvgc","position":0},{"hierarchy":{"lvl1":"Inverse design of perfectly vertical photonic (meta)grating coupler"},"content":"","type":"content","url":"/opt-pvgc","position":1},{"hierarchy":{"lvl1":"Inverse design of perfectly vertical photonic (meta)grating coupler","lvl2":"Geometry"},"type":"lvl2","url":"/opt-pvgc#geometry","position":2},{"hierarchy":{"lvl1":"Inverse design of perfectly vertical photonic (meta)grating coupler","lvl2":"Geometry"},"content":"\n\nimport math\nimport os\nimport matplotlib.pyplot as plt\nimport luminescent as lumi\nimport gdsfactory as gf\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport numpy as np\nfrom IPython.display import Image, display\n\npath = os.path.join(\"studies\", \"metagrating_coupler\")\nwl = 1.55  # um\nbw = 0.02\nwavelengths = [wl - bw / 2, wl, wl + bw / 2]  # um\n\nmaterial_library = lumi.MATERIAL_LIBRARY\nmaterial_library[\"background\"] = material_library[\"SiO2\"]  # set background material\nnSi = math.sqrt(material_library[\"Si\"][\"epsilon\"])\nnox = math.sqrt(material_library[\"SiO2\"][\"epsilon\"])\n\nw = 0.5  # gaussian beam waist\nR = 1.0 * w  # source radius\nwidth = 10  # of design region\nlength = 1.5 * width  # of design region\nw_wg = 0.5\nl_wg = 2 * w_wg\ndz = 0.1\n\n# margins\nlateral_port_margin = height_port_margin = 0.3\nxmargin = 1.5 * lateral_port_margin\nzmargin = 1.5 * height_port_margin\nbox_thickness = 0.5\nsource_port_margin = 1.5 * dz\n\nWG = 1, 0\nTEETH = 2, 0\nBBOX = 4, 0\nDESIGN = 100, 0\n\n# makes gdsfadory component to be optimized. has rectangular design region with port stubs. ports numbered clockwise from bottom left.\nc = gf.Component()\ndut = c << lumi.mimo(\n    length,\n    width,\n    w_wg=w_wg,\n    l_wg=l_wg,\n    west=1,\n    layer_wg=WG,\n    layer_design=DESIGN,\n    init=1,\n)\n\nxoffset = -(length - width + width / 2)\nyoffset = -(width / 2)\ndut.movex(xoffset)\ndut.movey(yoffset)\nc.add_port(\"o2\", port=dut.ports[\"o1\"])\n\nc << gf.components.bbox(\n    component=c, layer=BBOX, top=xmargin, bottom=xmargin, right=xmargin\n)\nc.plot()\n\n\n\n\n\n\n","type":"content","url":"/opt-pvgc#geometry","position":3},{"hierarchy":{"lvl1":"Inverse design of perfectly vertical photonic (meta)grating coupler","lvl2":"Solve"},"type":"lvl2","url":"/opt-pvgc#solve","position":4},{"hierarchy":{"lvl1":"Inverse design of perfectly vertical photonic (meta)grating coupler","lvl2":"Solve"},"content":"\n\n# layer stack. lower mesh order layers override higher mesh order layers. for 2.5D problems as is here, the mesher will slice thru middle of 'core' layer\nthickness_teeth = 0.07\nthickness_slab = 0.15\nthickness = thickness_teeth + thickness_slab\nlayer_stack = LayerStack(\n    layers={\n        \"design\": LayerLevel(\n            layer=LogicalLayer(layer=DESIGN),\n            zmin=thickness_slab,\n            thickness=thickness_teeth,\n            material=\"design\",\n            mesh_order=0,\n        ),\n        \"teeth\": LayerLevel(\n            layer=LogicalLayer(layer=TEETH),\n            zmin=thickness_slab,\n            thickness=thickness_teeth,\n            material=\"Si\",\n            mesh_order=1,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            zmin=0,\n            thickness=thickness,\n            material=\"Si\",\n            mesh_order=3,\n        ),\n    }\n)\n\n# make fiber mode\nnx = 2 * round(R / 0.05)\n_dx = 2 * R / nx\nx = np.linspace(-R + _dx / 2, R - _dx / 2, nx)\ny = np.linspace(-R + _dx / 2, R - _dx / 2, nx)\nX, Y = np.meshgrid(x, y)\ng = np.exp(-(X**2 + Y**2) / (2 * w**2))\n\nmodes = [\n    lumi.Mode(ports=[\"o1\"], fields={\"Ey\": g, \"Hx\": -nox * g}, dx=_dx),\n    lumi.Mode(ports=[\"o2\"]),\n]\n\n# additional ports not attached to gdsfactory component\nports = [\n    lumi.PlanePort(\n        name=\"o1\",\n        origin=[0, 0, thickness + dz],\n        frame=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n        length=2 * R,\n        width=2 * R,\n    )\n]\n\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n    )\n]\n\n# optimization targets of T params. o1@0 means optical port 1 on mode 0 (fundamental mode)\ntargets = [\n    lumi.Target(\"To2@0,o1@0\", 1.0, weight=1 / len(wavelengths), wavelength=x)\n    for x in wavelengths\n]\n\ntmax = (\n    1.0\n    * (length + width / 2 + 2 * box_thickness + zmargin + 2 * thickness + l_wg)\n    / wl\n    * nSi\n    + 5\n)  # max time [periods]\n\ndesigns = [\n    lumi.Design(\n        \"d1\",\n        layer=DESIGN,\n        lmin=0.2,\n        fill_material=\"Si\",\n        void_material=\"SiO2\",\n        symmetries=[\"y\"],\n        uniform_along=\"z\",\n    )\n]\noptimizer = lumi.Optimizer(\n    stoploss=0.2,\n    area_change=0.03,  # area change initial target\n    iters=20,  # max iters\n)\n\nlumi.make(\n    #\n    path=path,  # path to make problem folder\n    component=c,\n    wavelengths=wavelengths,\n    ports=ports,\n    modes=modes,\n    sources=sources,\n    boundaries=[\"PML\", \"PML\", [\"PEC\", \"PML\"]],\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    lateral_port_margin=lateral_port_margin,\n    height_port_margin=height_port_margin,\n    zmin=-box_thickness,  # zmin of simulation region\n    zmax=thickness + zmargin,  # zmax of simulation region\n    #\n    gpu=\"CUDA\",\n    relative_courant=0.9,\n    nres=4,  # number of grid points per wavelength in material (not vacuum)\n    tmax=tmax,  # total simulation time in periods\n    relative_pml_depths=[[1, 0.3], 0.3, 1],  # relative PML thicknesses in x, y, z\n    #\n    saveat=10,  # save frame every `saveat` periods for movie\n    force=True,  # delete and overwrite existing path\n    #\n    show_field=\"Ey\",\n    show_grid=False,\n    field_slices=[0, 0, thickness_teeth / 2 + thickness_slab],\n    geometry_slices=[0, 0, thickness_teeth / 2 + thickness_slab],\n    # inverse design parameters\n    targets=targets,\n    designs=designs,\n    optimizer=optimizer,\n)\n# studies adjoint optimization.\nlumi.solve(path)\ndisplay(Image(filename=os.path.join(path, \"peak.gif\")))\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/opt-pvgc#solve","position":5},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer"},"type":"lvl1","url":"/opt-demux","position":0},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer"},"content":"","type":"content","url":"/opt-demux","position":1},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Overview"},"type":"lvl2","url":"/opt-demux#overview","position":2},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Overview"},"content":"We inverse design a 1x4 wavelength demultiplexer (WDM) in silicon photonics splitting 4 wavelengths spaced 20nm apart into 4 output waveguides. Design region is a 8um x 8um square of silicon surrounded by silica cladding. We use differentiable simulation powered adjoint optimization to aim for high channel transmission while minimizing crosstalk. For sake of speed this is done in 2.5D (differs from 3D by only couple lines in the code).\n\n","type":"content","url":"/opt-demux#overview","position":3},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Geometry"},"type":"lvl2","url":"/opt-demux#geometry","position":4},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Geometry"},"content":"\n\nimport os\nimport math\nimport numpy as np\nimport luminescent as lumi\nimport gdsfactory as gf\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport matplotlib.pyplot as plt\nfrom IPython.display import Image, display\n\n\n# folder for saving config and results\npath = os.path.join(\"runs\", \"demux\")\n\nwavelength = 1.3  # characteristic wavelength\nwavelengths = 1.27, 1.29, 1.31, 1.33\n\n# layers\nWG = (1, 0)  # waveguide layer\nCLAD = (2, 0)  # cladding layer\nDESIGN = (100, 0)  # design region layer\n\n# makes gdsfactory component to be optimized. has rectangular design region with port stubs. ports numbered clockwise from bottom left\nlength = 6.0\nwidth = 6.0\nw_wg = 0.4\nl_wg = 3 * w_wg\nc = gf.Component()\ndut = lumi.mimo(\n    length,\n    width,\n    west=1,\n    east=4,\n    w_wg=w_wg,\n    l_wg=l_wg,\n    init=1,  # solid slab\n    layer_wg=WG,\n    layer_design=DESIGN,\n)\n# metadata. here we include design region info containing port locations useful for loading the optimized component after optimization\ninfo = {\"designs\": [{\"ports\": dut.info.ports}]}\ndut = c << dut\n\n# margin extensions\nlateral_port_margin = height_port_margin = 0.4\nxmargin = 1.5 * lateral_port_margin\nzmargin = 1.5 * height_port_margin\nsource_port_margin = 1.0 * (w_wg + 2 * lateral_port_margin)\next = c << gf.components.straight(source_port_margin, width=w_wg)\next.connect(\"o2\", dut.ports[\"o1\"])\n\n# add ports\nfor i in range(1, 6):\n    c.add_port(f\"o{i}\", port=dut.ports[f\"o{i}\"])\n\nc << gf.components.bbox(component=c, layer=CLAD, top=xmargin, bottom=xmargin)\nc.plot()\n\n\n\n","type":"content","url":"/opt-demux#geometry","position":5},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Solve"},"type":"lvl2","url":"/opt-demux#solve","position":6},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Solve"},"content":"\n\n# layer stack. lower mesh order layers override higher mesh order layers. for 2.5D problems as is here, the mesher will slice thru middle of 'core' layer\nthickness = 0.22\nmaterials_library = lumi.MATERIALS_LIBRARY\nnSi = math.sqrt(materials_library[\"Si\"][\"epsilon\"])\nmaterials_library.update(\n    {\n        \"design\": lumi.PlaceholderMaterial(mesh_density=nSi),  # placeholder material for design region\n        \"background\": materials_library[\"SiO2\"],\n    }\n)\n\nlayer_stack = LayerStack(\n    layers={\n        \"design\": LayerLevel(\n            layer=LogicalLayer(layer=DESIGN),\n            thickness=thickness,\n            zmin=0.0,\n            material=\"design\",\n            mesh_order=0,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=thickness,\n            zmin=0.0,\n            material=\"Si\",\n            mesh_order=1,\n        ),\n    }\n)  \n\n# time [periods at characteristic wavelength ]\nTsim = (source_port_margin + 2 * l_wg + 4 * (length + width)) / wavelength * nSi\n\n# each mode will be solved for sources and monitors\nmodes = [lumi.Mode(wavelength=wavelength)]\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n        wavelength=wavelength,\n        bandwidth=0.2,\n    )\n]\ndesigns = [\n    lumi.Design(\n        name=\"d1\",\n        layer=DESIGN,\n        lmin=0.15,\n        fill_material=\"Si\",\n        void_material=\"SiO2\",\n    )\n]\n# optimization targets of Tsim params.\n# o1@0 means optical port 1 on mode 0 (fundamental mode)\ntargets = [\n    lumi.Target(\n        key=f\"To{i+2}@0,o1@0\",\n        target=1.0,\n        weight=1 / 4,\n        wavelength=wl,\n    )\n    for i, wl in enumerate(wavelengths)\n]\n\noptimizer = lumi.Optimizer(stoploss=0.1, iters=50,momentum=.8)\n\nkwargs = dict(\n    path=path,  # path to make problem folder\n    component=c,\n    wavelengths=wavelengths,\n    wavelength=wavelength,\n    modes=modes,\n    info=info,\n    sources=sources,\n    #\n    lateral_port_margin=lateral_port_margin,\n    height_port_margin=height_port_margin,\n    zmin=-zmargin,\n    zmax=thickness + zmargin,\n    #\n    materials_library=materials_library,\n    layer_stack=layer_stack,\n    #\n    gpu=\"CUDA\",\n    nres=6,  # number of grid points per wavelength in material (not vacuum)\n    relative_courant=0.9,\n    Tsim=Tsim,\n    force=True,  # overwrite files in existing path\n    #\n    approx_2D_mode=\"TE\",  # makes problem 2.5D instead of 3D\n    z=thickness / 2,  # z coordinate to slice the 2.5D problem at\n    #\n    designs=designs,\n    targets=targets,\n    optimizer=optimizer,\n)\nlumi.make(**kwargs)\nlumi.solve(path)\ndisplay(Image(filename=os.path.join(path, \"peak.png\")))\nlumi.plot(path)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/opt-demux#solve","position":7},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Post optimization simulation"},"type":"lvl2","url":"/opt-demux#post-optimization-simulation","position":8},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Post optimization simulation"},"content":"\n\n# new simulation with optimized design and finer spaced wavelengths\ndel kwargs['targets']\ndel kwargs['optimizer']\nwavelengths1=np.linspace(1.26, 1.34, 81)\nkwargs.update(\n    wavelengths=wavelengths1,\n    load_saved_designs=True)\nlumi.make(**kwargs)\nlumi.solve(path)\n\n\n\n\n\n\n\n\n\nsol = lumi.load(path)\nx = wavelengths1\nys = [lumi.query(sol, f\"To{i}@0,o1@0\") for i in range(2, 6)]\nplt.figure()\nfor y in ys:\n    plt.plot(x, [10*math.log10( y) for y in y])\nplt.scatter(wavelengths, [0]*len(wavelengths), 100, marker=\"*\")\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"transmission [dB]\")\nplt.show()\n\n\n\n","type":"content","url":"/opt-demux#post-optimization-simulation","position":9},{"hierarchy":{"lvl1":"Photonic PDK"},"type":"lvl1","url":"/pdk","position":0},{"hierarchy":{"lvl1":"Photonic PDK"},"content":"Lumi Photonic PDK (process design kit) is a library of AI inverse designed photonic components for PIC (photonic integrated circuit). Unlike a traditional PDK, each component here is more akin to a reference design that shows what’s possible. In most cases, they should be re-optimized for your specific needs and process node.","type":"content","url":"/pdk","position":1},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Available components"},"type":"lvl2","url":"/pdk#available-components","position":2},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Available components"},"content":"Updating... Please check back mid January\n\nPerfectly vertical grating coupler\n","type":"content","url":"/pdk#available-components","position":3},{"hierarchy":{"lvl1":"Simulation"},"type":"lvl1","url":"/sim","position":0},{"hierarchy":{"lvl1":"Simulation"},"content":"We recommend first going through a tutorial to get a feel on running simulations. Then come back here for detailed explanations.","type":"content","url":"/sim","position":1},{"hierarchy":{"lvl1":"Simulation","lvl2":"Overview"},"type":"lvl2","url":"/sim#overview","position":2},{"hierarchy":{"lvl1":"Simulation","lvl2":"Overview"},"content":"Everything revolves around the simulation folder path you specify in make, which uses Python frontend to write problem.json and other config files. solve then reads them and invokes compiled Julia backend to run simulation, producing solution.json. load then loads it into a","type":"content","url":"/sim#overview","position":3},{"hierarchy":{"lvl1":"Simulation","lvl2":"Units"},"type":"lvl2","url":"/sim#units","position":4},{"hierarchy":{"lvl1":"Simulation","lvl2":"Units"},"content":"Length and frequency units are arbitrary so long as they are consistent. Time is in periods of the characteristic wavelength. Under the hood everything gets normalized around the characteristic wavelength and its period.","type":"content","url":"/sim#units","position":5},{"hierarchy":{"lvl1":"Simulation","lvl2":"Geometry"},"type":"lvl2","url":"/sim#geometry","position":6},{"hierarchy":{"lvl1":"Simulation","lvl2":"Geometry"},"content":"","type":"content","url":"/sim#geometry","position":7},{"hierarchy":{"lvl1":"Simulation","lvl3":"Option 1: gdsfactory","lvl2":"Geometry"},"type":"lvl3","url":"/sim#option-1-gdsfactory","position":8},{"hierarchy":{"lvl1":"Simulation","lvl3":"Option 1: gdsfactory","lvl2":"Geometry"},"content":"gdsfactory is a popular Python library for programmatic electronic layout. It uses layer_stack to convert 2D layers to 3D geometry. make accepts gdsfactory layer_stack and component whose ports automatically become simulation ports. .gds and .gerber files can also be imported into gdsfactory components.","type":"content","url":"/sim#option-1-gdsfactory","position":9},{"hierarchy":{"lvl1":"Simulation","lvl3":"Option 2: 3D mesh file import","lvl2":"Geometry"},"type":"lvl3","url":"/sim#option-2-3d-mesh-file-import","position":10},{"hierarchy":{"lvl1":"Simulation","lvl3":"Option 2: 3D mesh file import","lvl2":"Geometry"},"content":"Create geometry in your favorite CAD and or another simulation tool. Then export each body as .obj (can be saved from .stl or .step) file. Then place them in geometry folder inside simulation folder using the convention {mesh_order}{SEP}{material_name}{SEP}{layer_name}{SEP}{body_name}.obj eg 1#Si#core#wg.obj. Lower mesh order overrides higher mesh order.","type":"content","url":"/sim#option-2-3d-mesh-file-import","position":11},{"hierarchy":{"lvl1":"Simulation","lvl2":"Boundaries"},"type":"lvl2","url":"/sim#boundaries","position":12},{"hierarchy":{"lvl1":"Simulation","lvl2":"Boundaries"},"content":"Default is [\"PML\", \"PML\", \"PML\"] for x, y, z. Each dimension can be further split into + and - eg [[\"PEC\", \"PML\"], ...]. Boundary options include \"PEC\", \"PMC\", \"periodic\". relative_pml_depths can shorten PML depths and reduce computation load along dimensions with small or glazing incident radiation eg [1, 1, 0.3] in many circuit setups.","type":"content","url":"/sim#boundaries","position":13},{"hierarchy":{"lvl1":"Simulation","lvl2":"Mesh"},"type":"lvl2","url":"/sim#mesh","position":14},{"hierarchy":{"lvl1":"Simulation","lvl2":"Mesh"},"content":"Adaptive graded mesh proportions more points to regions of high refractive index and fine features. It also snaps to body boundaries including thin sheets in RF. nres arg in make controls number of points per characteristic wavelength adjusted locally for refractive index. mesh_density relative to vacuum which is by default the refractive index can also be manually set in material constructors. This is useful for mesh overrides or metal materials with undefined refractive index.","type":"content","url":"/sim#mesh","position":15},{"hierarchy":{"lvl1":"Simulation","lvl2":"Materials"},"type":"lvl2","url":"/sim#materials","position":16},{"hierarchy":{"lvl1":"Simulation","lvl2":"Materials"},"content":"materials_library dictionary maps material names eg Si to their property entries which use constructors below. It must contain the special key background denoting the background material. The default lumi.MATERIALS_LIBRARY contains common materials and can be modified. Material properties are in relative units so  ϵ₀ = μ₀ = n₀ = Z₀ = 1. This means you can simply use relative permittivity. Though for other properties like conductivity you must convert to relative units keeping in mind 377 Ω = 1 and characteristic wavelength in your length units = 1.    .. autofunction:: luminescent.setup.Material\n    .. autofunction:: luminescent.setup.PECMaterial\n    .. autofunction:: luminescent.setup.PlaceholderMaterial","type":"content","url":"/sim#materials","position":17},{"hierarchy":{"lvl1":"Simulation","lvl2":"Ports"},"type":"lvl2","url":"/sim#ports","position":18},{"hierarchy":{"lvl1":"Simulation","lvl2":"Ports"},"content":"Plane ports are automatically extracted from gdsfactory component or imported geometry. gdsfactory derived ports are extended by lateral_port_margin and height_port_margin args in make for creating modal sources and monitors.\n\nAdditional ports (not from gdsfactory or marked in imported geometry) can be created as follows and passed to make via ports    .. autofunction:: luminescent.setup.PlanePort\n    .. autofunction:: luminescent.setup.SpherePort","type":"content","url":"/sim#ports","position":19},{"hierarchy":{"lvl1":"Simulation","lvl2":"Modes"},"type":"lvl2","url":"/sim#modes","position":20},{"hierarchy":{"lvl1":"Simulation","lvl2":"Modes"},"content":"    .. autofunction:: luminescent.setup.Mode","type":"content","url":"/sim#modes","position":21},{"hierarchy":{"lvl1":"Simulation","lvl2":"Monitors"},"type":"lvl2","url":"/sim#monitors","position":22},{"hierarchy":{"lvl1":"Simulation","lvl2":"Monitors"},"content":"Each port automatically has a monitor. Plane port gets modal monitor which accumulates DFT fields in time domain to obtain field profiles in frequency domain. Modal decomposition then makes forward and backward wave coefficients of each mode wrt frequency. Sphere radiation port works similarly but doesn’t necessarily involve modes.","type":"content","url":"/sim#monitors","position":23},{"hierarchy":{"lvl1":"Simulation","lvl2":"Sources"},"type":"lvl2","url":"/sim#sources","position":24},{"hierarchy":{"lvl1":"Simulation","lvl2":"Sources"},"content":"    .. autofunction:: luminescent.setup.Source","type":"content","url":"/sim#sources","position":25},{"hierarchy":{"lvl1":"Simulation","lvl2":"Solution"},"type":"lvl2","url":"/sim#solution","position":26},{"hierarchy":{"lvl1":"Simulation","lvl2":"Solution"},"content":"solve calls system command luminescent to do simulation. It writes solution.json which references numpy arrays in the auxiliary folder .solution.json. load loads them into a dictionary which query can further process into derived quantities eg S-parameters","type":"content","url":"/sim#solution","position":27},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"type":"lvl1","url":"/test-fss","position":0},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"content":"","type":"content","url":"/test-fss","position":1},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"type":"lvl2","url":"/test-fss#overview","position":2},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"content":"We simulate microwave frequency selective surface (FSS) with 12GHz bandstop. periodic Metal cross array on dielectric substrate. Compare with Tidy3D example \n\nhttps://​www​.flexcompute​.com​/tidy3d​/examples​/notebooks​/MicrowaveFrequencySelectiveSurface\n\n","type":"content","url":"/test-fss#overview","position":3},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"type":"lvl2","url":"/test-fss#geometry","position":4},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport math\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# simulation folder\nstudy='microwave_frequency_selective_surface'\npath = os.path.join('studies', study)\n\n# length and frequency units are arbitrary\nfrequency = 12  # origin frequency GHz\nbw = 4  # bandwidth\ndf = 0.05  # frequency step\nwl1f = 300  # vacuum wavelength at 1 unit of frequency in your units\nwl = wl1f / frequency  # characteristic wavelength\nfrequencies = np.linspace(frequency-bw/2, frequency+bw/2, round(bw/df+1))\n\n# unit cell [mm]\nP = 15  # periodicity\nL = 9.4  # length of cross\nW = 2.0  # width of cross stub\nd = 2.2  # height of substrate\nth = 0.1  # metal thickness\ngap = 30.0  # air gap below and above - keeps resonant evanescent field from coupling to lossy PML\nmargin = 2.0\n\n# adaptive meshing\ndx=W/5  # desired spatial resolution\nnres = 16\ndx0 = wl / nres\nmesh_density = dx0 /dx\n\n# material_library\nmaterial_library = lumi.MATERIAL_LIBRARY\nmaterial_library[\"sub\"] = lumi.Material(epsilon=2.5, mesh_density=mesh_density)\nmaterial_library[\"PEC\"] = lumi.PECMaterial(mesh_density=mesh_density)\n\n# make geometry in gdsfactory. 1/4 section of unit cell due to symmetry\n# alternatively can import .gds into gdsfactory\n\nWG = (1, 0)\nBBOX = (2, 0)\n\nlayer_stack = LayerStack(\n    layers={\n        \"WG\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=th,\n            zmin=0,\n            material=\"PEC\",\n            mesh_order=1,\n        ),\n        \"sub\": LayerLevel(\n            layer=LogicalLayer(layer=BBOX),\n            thickness=d,\n            zmin=-d,\n            material=\"sub\",\n            mesh_order=2,\n        ),\n    }\n)\n\nc = gf.Component()\nc.add_polygon(\n    [(0, 0), (0, L / 2), (W / 2, L / 2), (W / 2, 0)],\n    layer=WG,\n)\np = c.add_polygon(\n    [(W / 2, W / 2), (W / 2, 0), (L / 2, 0), (L / 2, W / 2)],\n    layer=WG,\n)\nc.add_polygon([(0, 0), (0, P / 2), (P / 2, P / 2), (P / 2, 0)], layer=BBOX)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-fss#geometry","position":5},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Problem"},"type":"lvl2","url":"/test-fss#problem","position":6},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Problem"},"content":"\n\n\n\n\n\nxc = P / 4\nyc = P / 4\nports = [\n    lumi.PlanePort(\n        name='o1',\n        origin=[xc, yc, th + gap],\n        frame=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n    ),\n    lumi.PlanePort(\n        name='o2',\n        origin=[xc, yc, -d- gap],\n        frame=[[-1, 0, 0], [0, 1, 0], [0, 0, -1]],\n    ),\n]\n\nnx=ny=round(P/2/dx)\na=np.ones((nx,ny))\nmodes = [lumi.Mode(\n    frequencies=[frequency],\n    fields=[[{\"Ex\": a, \"Hy\": a},{\"Ey\": a, \"Hx\": -a}]],\n    start=[-P/4, -P/4],\n    stop=[P/4, P/4],\n    )]\n\nsources = [lumi.Source(\"o1\", source_port_margin=margin, frequency=frequency, bandwidth=bw)]\n\nviews=[lumi.View('Ex',x=0,y=0,z=th/2)]\n\n# Luminescent community cloud client\nemail=____# replace with your registered email\nclient=lumi.Client(email,cloud='luminescent_community_cloud')\n\nlumi.make(\n    path,\n    component=c,\n    frequencies=frequencies,\n    wl1f=wl1f,\n    # antisymmetric/PEC/odd vs symmetric/PMC/even symmetry\n    boundaries=[\"PEC\", \"PMC\", \"PML\"],\n    #\n    sources=sources,\n    ports=ports,\n    modes=modes,\n    zmin=-gap-d,\n    zmax= th + gap + margin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    nres=nres,\n    tmax=50,  # max time [periods]\n    energy_decay_threshold=0.001,  # field decay threshold for stopping simulation\n    saveat=1,\n    # visualization\n    views=views,\n    # \n    client=client,\n)\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-fss#problem","position":7},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Movie"},"type":"lvl2","url":"/test-fss#movie","position":8},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Movie"},"content":"\n\nlumi.movie(path)\n\n\n\n\n\n","type":"content","url":"/test-fss#movie","position":9},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"type":"lvl2","url":"/test-fss#analysis","position":10},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = [10 * math.log10(x) for x in lumi.query(sol,'T2,1')]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n","type":"content","url":"/test-fss#analysis","position":11},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"type":"lvl1","url":"/test-ring","position":0},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"content":"","type":"content","url":"/test-ring","position":1},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"type":"lvl2","url":"/test-ring#overview","position":2},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"content":"We simulate small silicon ring resonator coupled to parallel waveguides buried in silica cladding. We use midplane z PMC symmetry to slash cell count by half.\n\n","type":"content","url":"/test-ring#overview","position":3},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"type":"lvl2","url":"/test-ring#geometry","position":4},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# simulation folder \nstudy='photonic_ring_resonator'\npath = os.path.join('studies', study)\n\n# length units are arbitrary so long as they are consistent, in this case [um]. everything gets normalized around origin wavelength and period at backend.\nwavelength = 1.55  # characteristic wavelength [um]\nbandwidth = 0.1  # wavelength bandwidth [um]\nwavelengths = np.linspace(wavelength - bandwidth / 2, wavelength + bandwidth / 2, 401)\n\nr = 3.1  # radius of ring\nw_wg = 0.4  # width of waveguide\ngap = 0.1  # gap between waveguide and ring\nh_wg = 0.18  # h_wg of waveguide\n\n# gds layers\nWG = (1, 0)  # waveguide layer\nBBOX = (10, 0)  # bounding box layer\n\n# we create geometry in gdsfactory. alternatively, you can import .gds layout into gdsfactory or .stl bodies directly into ours\n\n# margins\nheight_port_margin = lateral_port_margin = 0.8\nmargin = 1.2 * lateral_port_margin\nzmargin = 1.2 * height_port_margin\nsource_port_margin = 1.0 * (w_wg + 2 * lateral_port_margin)\n\n# draw layout in gdsfactory. `gf.components` defaults to layer WG = (1, 0)\nc = gf.Component()\n\ndut = c << gf.components.ring(radius=r, width=w_wg, layer=WG)\n\nl_branch = 2 * r + w_wg + source_port_margin + 2*margin\nxoffset = -source_port_margin - margin - r - w_wg / 2\nyoffset = w_wg + gap + r\nbranch_top = c << gf.components.straight(length=l_branch, width=w_wg)\nbranch_top.move((xoffset, w_wg + gap + r))\n\nbranch_bottom_left = c << gf.components.straight(length=source_port_margin, width=w_wg)\nbranch_bottom_left.move((xoffset, -yoffset))\n\nbranch_bottom_right = c << gf.components.straight(length=l_branch - source_port_margin, width=w_wg)\nbranch_bottom_right.connect(\"o1\", branch_bottom_left.ports[\"o2\"])\n\n\n# add ports\nc.add_port(\"o1\", port=branch_bottom_right.ports[\"o1\"])\nc.add_port(\"o2\", port=branch_bottom_right.ports[\"o2\"])  # thru channel\nc.add_port(\"o3\", port=branch_top.ports[\"o1\"])  # drop channel\n\nc << gf.components.bbox(component=c, layer=BBOX, top=margin, bottom=margin)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-ring#geometry","position":5},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"type":"lvl2","url":"/test-ring#solve","position":6},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"content":"\n\n# for gdsfactory, we need vertical layer stack. \"core\" layer is special as `height_port_margin` are demarcated from it for defining modal sources and monitors. during 3d meshing lower mesh order layers supplant higher mesh order layers\nlayer_stack = LayerStack(\n    layers={\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=h_wg/2,\n            zmin=0.0,\n            material=\"Si\",\n            mesh_order=10,\n        ),\n    }\n)\n\n# our default lumi.MATERIAL_LIBRARY lib covers limited range of photonic and PCB material_library. here we create our own material_library. `background` is special and tags regions outside any bodies during meshing\nmaterial_library = {\n    \"Si\": lumi.Material(epsilon=12.25),\n    \"SiO2\": lumi.Material(epsilon=2.25),\n}\nmaterial_library[\"background\"] = material_library[\n    \"SiO2\"\n]  \n\n# source launches `source_port_margin` in front of port. it's bidirectional: the other direction goes into PML. pulse spectrum rolls off gradually past bandwidth limits.\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n        wavelength=wavelength,\n        bandwidth=wavelength/5,\n        modenums=[0],  # fundamental mode only\n    )\n]\n\nlx = w_wg + 2 * lateral_port_margin\nly = h_wg + 2 * height_port_margin\nmodes = [\n    lumi.Mode(\n        wavelengths=np.linspace(wavelengths[0], wavelengths[-1],5),\n        start=[-lx / 2, 0],  # local xy frame\n        stop=[lx / 2, h_wg/2 + height_port_margin],\n        boundaries=['PML',('PMC','PML')]\n    )\n]\n\n# Luminescent community cloud client\nemail=____ # replace with your registered email\nclient=lumi.Client(email,cloud='luminescent_community_cloud')\n\nlumi.make(\n    path=path,\n    component=c,\n    wavelengths=wavelengths,\n    sources=sources,\n    modes=modes,\n    # limits\n    boundaries=['PML','PML',('PMC','PML')], # z midplane PMC symmetry\n    zmin=0,\n    zmax=h_wg/2 + zmargin,\n    # materials and layers\n    material_library=material_library,\n    layer_stack=layer_stack,\n    # accuracy and speed settings\n    nres=8,  # number of grid points per wavelength in material (not vacuum)\n    relative_courant=0.95,  # relative to maximum theoretical Courant number at\n    relative_pml_depths=[1, 1, 0.25],  \n    tmax=1000,  # max time [periods]\n    energy_decay_threshold=0.001,  # field energy decay threshold for stopping simulation\n    saveat=25,  # save and plot field every _ periods, involves slow disk write\n    # visualization\n    views=[lumi.View(\"Hz\",x=0,y=0,z=0)],\n    # \n    client=client,\n)\n\n\n\n\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-ring#solve","position":7},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"type":"lvl2","url":"/test-ring#visualize","position":8},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"content":"\n\n\n\nlumi.movie(path) # full movie - this may take a while to generate\n\n\n\n\n\n","type":"content","url":"/test-ring#visualize","position":9},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"type":"lvl2","url":"/test-ring#analysis","position":10},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = wavelengths\n\n# S or T params. wavelength or frequency ordered depending on problem setup\ny = lumi.query(sol, \"To3@0,o1@0\")  # same as y=np.abs2(sol['waves']['o3@0+']/sol['waves']['o1@0-'])\n# y = lumi.query(sol, \"T3,1\") # flux\n\nplt.plot(x, y)\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"drop channel transmitted power\")\nplt.show()\n\n\n\n","type":"content","url":"/test-ring#analysis","position":11},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"type":"lvl1","url":"/test-stub","position":0},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"content":"","type":"content","url":"/test-stub","position":1},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"type":"lvl2","url":"/test-stub#overview","position":2},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"content":"We simulate a quarter wave stub bandstop filter in RF microstrip with nominal 5GHz notch.\n\n","type":"content","url":"/test-stub#overview","position":3},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"type":"lvl2","url":"/test-stub#geometry","position":4},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# simulation folder \nstudy='microstrip_stub_filter'\npath = os.path.join('studies', study)\n\n# length and frequency units are arbitrary but must be consistent. here we use mm and GHz\nfrequency = 5  # characteristic frequency in GHz\nfrequencies = np.linspace(3, 7, 81).tolist()\nwl1f = 300  # vacuum wavelength at 1 unit of frequency, all in your units\nwavelength = wl1f / frequency  # characteristic wavelength\nbandwidth = max(frequencies) - min(frequencies)\n\n# microstrip\nw_line = 1.52  # mm\nth = 0.035  # mm\nd = 0.8  # mm\nc = 87.5 / 139  # relative signal speed, from microstrip calculator\n\nwl_sig = wl1f * c / frequency  # wavelength in the signal line\nl_stub = wl_sig / 4 # quarter-wave stub length\nl_feed = 1 * l_stub\nlateral_port_margin = height_port_margin = 2 * d\nmargin = zmargin = 1.25 * lateral_port_margin\nlx_mode = w_line + 2 * lateral_port_margin  # lateral size of mode region\nsource_port_margin = 1.5 * (w_line + 2 * lateral_port_margin)\n\n# layers\nFEED = 1, 0\nSTUB = 2, 0\nSUB = 10, 0\n\n# make geometry in gdsfadory\n# alternatively can import .gds into gdsfadory\nc = gf.Component()\nfeed = c << lumi.straight(length=l_feed, width=w_line, layer=FEED)\nstub = c << lumi.straight(length=l_stub, width=w_line, layer=STUB)\nstub.rotate(90)\nstub.movex(l_feed / 2)\next = c << lumi.straight(source_port_margin, width=w_line, layer=FEED)\next.connect(\"o2\", feed.ports[\"o1\"])\n\nfor i in (1, 2):\n    c.add_port(f\"o{i}\", port=feed.ports[f\"o{i}\"])\n\nc << gf.components.bbox(component=c, layer=SUB, top=margin, bottom=margin)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-stub#geometry","position":5},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"type":"lvl2","url":"/test-stub#solve","position":6},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"content":"\n\n# adaptive meshing\nnres = 16\ndx0 = wavelength / nres\n\nlayer_stack = LayerStack(\n    layers={\n        \"feed\": LayerLevel(\n            layer=LogicalLayer(layer=FEED),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=10,\n        ),\n        \"stub\": LayerLevel(\n            layer=LogicalLayer(layer=STUB),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=20,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=SUB),\n            zmin=-d,\n            thickness=d,\n            material=\"sub\",\n            mesh_order=30,\n        ),\n    }\n)\n\n# materials\neps_sub = 4.3\nn_sub = np.sqrt(eps_sub)\n\ndx = w_line / 4  # 4 mesh points across the strip\nn_PEC = dx0 / (dx)  # mesh density relative to vacuum\n\nmaterial_library = {\n    \"sub\": lumi.Material(epsilon=eps_sub),\n    \"PEC\": lumi.PECMaterial(mesh_density=n_PEC),\n}\nmaterial_library[\"background\"] = lumi.Material(epsilon=1.0)\n\n_dx=dx \n_dy=th\nmodes = [\n    lumi.Mode(\n        ports=[\"o1\", \"o2\"],\n        frequencies=[frequency],\n        metallic_boundaries=[\"y-\", \"feed\"],\n        nmodes=1,\n        start=[-lx_mode/2, -d], # local xy frame, local y=0 at global zmin of port layer\n        stop=[lx_mode/2, th + height_port_margin],\n        voltage_line=[(0, -d), (0, 0)], # optional\n        current_loop=[\n            (-w_line / 2 - _dx,  - _dy),\n            (-w_line / 2 - _dx,  th + _dy),\n            (w_line / 2 + _dx,  th + _dy),\n            (w_line / 2 + _dx,  - _dy),\n        ], # optional\n    )\n]\n\nsources = [\n    lumi.Source(\n        \"o1\", frequency=frequency, duration=0.5, source_port_margin=source_port_margin\n    ) # modulated Gaussian pulse\n]\n\nviews=[\n        lumi.View(\"Ez\", x=-source_port_margin, y=0, z=-d / 2),\n        lumi.View(\"Hz\", z=th / 2),\n    ]\n \n# Luminescent community cloud client\nemail=____# replace with your registered email\nclient=lumi.Client(email,cloud='luminescent_community_cloud')\n\nlumi.make(\n    path=path,\n    component=c,\n    frequency=frequency, # characteristic frequency\n    frequencies=frequencies,\n    wl1f=wl1f,\n    sources=sources,\n    modes=modes,\n    # bounds\n    boundaries=[\"PML\", \"PML\", [\"PEC\", \"PML\"]],\n    zmin=-d,\n    zmax=th + zmargin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    # performance\n    nres=nres,\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    relative_pml_depths=[1, 0.3, 0.3],\n    energy_decay_threshold=0.01,  # field decay threshold for stopping simulation\n    saveat=1,  # save frame for plotting every _ periods\n    # visualization\n    views=views,\n    # \n    client=client,\n)\n\n\n\n\n\n\n\n\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-stub#solve","position":7},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"type":"lvl2","url":"/test-stub#visualize","position":8},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"content":"\n\nlumi.movie(path)\n\n\n\n\n\n","type":"content","url":"/test-stub#visualize","position":9},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"type":"lvl2","url":"/test-stub#analysis","position":10},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = lumi.query(sol, \"To2,o1\") # convenience function for T-parameters using modal decomposition\n\n# S-parameters can also be computed explicitly from complex valued modal or voltage waves:\n# y = np.abs2(sol[\"waves\"][\"o2@0+\"] / sol[\"waves\"][\"o1@0-\"]) # explicit T21 using forward/backward modal amplitudes\n# y = np.abs2(sol[\"waves\"][\"o2+\"] / sol[\"waves\"][\"o1-\"]) # using forward/backward voltage waves\n\ny = [10 * np.log10(v) for v in y]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n\n\ny=377*sol['Z']['o1']\nplt.plot(x,np.real(y),label=\"Real\",color='orange')\nplt.plot(x,np.imag(y),label=\"Imaginary\",color='blue')\nplt.xlabel(\"f [GHz]\")\nplt.ylabel('complex line impedance [Ohms]')\nplt.legend()\nplt.show()\n\n","type":"content","url":"/test-stub#analysis","position":11}]}