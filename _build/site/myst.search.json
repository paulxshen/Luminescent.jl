{"version":"1","records":[{"hierarchy":{"lvl1":"Features"},"type":"lvl1","url":"/features","position":0},{"hierarchy":{"lvl1":"Features"},"content":"Fully differentiable and GPU-accelerated finite difference time domain (FDTD) engine for full wave electromagnetic simulation and inverse design.\n\nPowerful\n\nGenerative inverse design and simulation in just few lines of Python code!\n\nBroadband and multimode S-parameters\n\nEmbedded mode solver for modal sources and monitors\n\n.gds and gdsfactory integration\n\n.stl / .step  3D geometry import\n\nSmart\n\nFully differentiable (native automatic differentiation in Julia)\n\nSimultaneous inverse design of multiple 2D and 3D structures\n\nLength scale controlled geometry optimizer with fabrication constraints\n\nFast\n\nGPU acceleration on NVIDIA, AMD, and Apple Silicon\n\nAdaptive graded mesh reduces cell count\n\nTensor subpixel smoothing boosts accuracy\n\nComprehensive\n\nModal sources, plane waves, Gaussian beams, custom sources\n\nOblique sources and monitors\n\nPML, periodic, PEC, PMC boundaries\n\nNear and far field radiation patterns\n\nNonlinear, dispersive and anisotropic materials","type":"content","url":"/features","position":1},{"hierarchy":{"lvl1":"Home"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Home"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"type":"lvl2","url":"/#overview","position":2},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"content":"Luminescent AI harnesses physics grounded AI for designing electromagnetic structures in photonics and RF. We offer Lumi FDTD for full wave simulations and inverse design, and Lumi Photonic PDK of inverse designed photonic components.","type":"content","url":"/#overview","position":3},{"hierarchy":{"lvl1":"Home","lvl2":"About"},"type":"lvl2","url":"/#about","position":4},{"hierarchy":{"lvl1":"Home","lvl2":"About"},"content":"We’re Stanford alum and founded Luminescent AI in 2025 to democratize photonic and RF design with physics grounded AI.\n\nLinkedIn: follow us for updates and opportunities!\n\nWebsite\nEmail: \n\npaul@luminescentai​.comWhatsApp and WeChat: +1 (650) 776-7724","type":"content","url":"/#about","position":5},{"hierarchy":{"lvl1":"Installation"},"type":"lvl1","url":"/install","position":0},{"hierarchy":{"lvl1":"Installation"},"content":"","type":"content","url":"/install","position":1},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"type":"lvl2","url":"/install#option-1-luminescent-community-cloud-free-and-public","position":2},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"content":"Run on our latest Nvidia Blackwell GPUs for free! Just \n\nregister (allow 1 business day for processing) and install our python frontend client. Unlike before, no need to install the backend. See our simulation tutorials afterwards. Community cloud only supports simulations (not inverse design). Everything uploaded is publicly visible. If you want a private and secured environment, please upgrade to an enterprise cloud.","type":"content","url":"/install#option-1-luminescent-community-cloud-free-and-public","position":3},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1A: Frontend client on Google Colab","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"type":"lvl3","url":"/install#option-1a-frontend-client-on-google-colab","position":4},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1A: Frontend client on Google Colab","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"content":"pip install luminescent\n\nUnlike before, we’re only installing the python frontend client. This only takes a minute and the basic free CPU runtime is sufficient. See \n\nGoogle Colab example","type":"content","url":"/install#option-1a-frontend-client-on-google-colab","position":5},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1B: Frontend client on local machine","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"type":"lvl3","url":"/install#option-1b-frontend-client-on-local-machine","position":6},{"hierarchy":{"lvl1":"Installation","lvl3":"Option 1B: Frontend client on local machine","lvl2":"Option 1: Luminescent Community cloud (free and public)"},"content":"Due to a issue with pymeshlab dependency, we currently only support Python 3.12 . If that’s your default python, do:\n\npip install luminescent\n\nIf you installed multiple Python versions, you can also explicitly do:\n\npath_to_python3.12 -m pip install luminescent (replace path_to_python3.12 with your actual python 3.12 path)\n\nSome systems can take few minutes to initialize dependencies on first run.","type":"content","url":"/install#option-1b-frontend-client-on-local-machine","position":7},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 2: Luminescent Enterprise cloud (private and secure)"},"type":"lvl2","url":"/install#option-2-luminescent-enterprise-cloud-private-and-secure","position":8},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 2: Luminescent Enterprise cloud (private and secure)"},"content":"Similar to community cloud but private and secured for your organization. Comes with premium support and consulting. Pricing is a fixed annual fee plus $3 per GPU hour (similar to raw rates on GCP or AWS). Sign up via \n\ninfo@luminescentai​.com","type":"content","url":"/install#option-2-luminescent-enterprise-cloud-private-and-secure","position":9},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 3: Local backend installation (advanced users)"},"type":"lvl2","url":"/install#option-3-local-backend-installation-advanced-users","position":10},{"hierarchy":{"lvl1":"Installation","lvl2":"Option 3: Local backend installation (advanced users)"},"content":"Customers of Enterprise cloud are also entitled to local backend binaries upon request.","type":"content","url":"/install#option-3-local-backend-installation-advanced-users","position":11},{"hierarchy":{"lvl1":"Perfectly Vertical Grating Coupler (PVGC) Inverse Design"},"type":"lvl1","url":"/opt-pvgc","position":0},{"hierarchy":{"lvl1":"Perfectly Vertical Grating Coupler (PVGC) Inverse Design"},"content":"","type":"content","url":"/opt-pvgc","position":1},{"hierarchy":{"lvl1":"Perfectly Vertical Grating Coupler (PVGC) Inverse Design","lvl2":"Geometry"},"type":"lvl2","url":"/opt-pvgc#geometry","position":2},{"hierarchy":{"lvl1":"Perfectly Vertical Grating Coupler (PVGC) Inverse Design","lvl2":"Geometry"},"content":"\n\nimport os\nimport numpy as np\nimport luminescent as lumi\nimport gdsfactory as gf\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport matplotlib.pyplot as plt\n\nwideband = False\nbidirectional = False\n\nif wideband and bidirectional:\n    study=\"wbPVGC\" # wideband bidirectional\nelif bidirectional:\n    study=\"bPVGC\" # bidirectional\nelse:\n    study=\"PVGC\"\n\n# folder for saving config and results\npath = os.path.join(\"studies\", study)\n\nwavelength=1.55\nif wideband:\n    bandwidth=.07\nelse:\n    bandwidth = 0.005\nwavelengths = np.linspace(wavelength-bandwidth/2, wavelength+bandwidth/2, 5)\n\neps_Si = 12.25\neps_SiO2 = 2.1708\nn_Si = np.sqrt(eps_Si)\nn_SiO2 = np.sqrt(eps_SiO2)\nλ_Si=wavelength/n_Si\nλ_SiO2=wavelength/n_SiO2\n\nmaterial_wg='Si'\nmaterial_clad = \"SiO2\"\n\nmaterial_library = {\n    \"Si\": lumi.Material(eps_Si),\n    \"SiO2\": lumi.Material(eps_SiO2),\n}\nmaterial_library[\"background\"] = material_library[\"SiO2\"]  # set background material\nmaterial_library[\"design\"] = lumi.PlaceholderMaterial(n_Si)\n\nw = 10.4  # gaussian beam waist\nr= w / 2  # source gaussian radius\nR=1.5*r\n\nif bidirectional:\n    w_design =1*R  # of design region\n    l_design =1.5 *R # of design region\nelse:\n    w_design =1*R  # of design region\n    l_design =2*R # of design region\n\nw_wg = 0.5\nl_wg = 2 * w_wg\nh_wg = 0.22\nd_etch = 0.07\nh_slab = h_wg - d_etch\n\n# margins\nlateral_port_margin = height_port_margin = 1*h_wg\nmargin = 1.25 * lateral_port_margin\nzmargin = 1.25 * height_port_margin\n\nλ_Si=wavelength/n_Si\nλ_SiO2=wavelength/n_SiO2\n\nnres = 4  # number of grid points per wavelength in material (not vacuum)\n\ndz=λ_SiO2/ nres\nsource_port_margin = 2*dz\n\ngap1=zmargin\ngap2=1/4*λ_SiO2\nz_port = h_wg+gap1\nzmin=-gap2\nzmax=z_port+source_port_margin\n\nWG = 1, 0\nBBOX = 10, 0\nDESIGN = 500, 0\n\n# makes gdsfadory component to be optimized. has rectangular design region with port stubs. ports numbered clockwise from bottom left.\nc = gf.Component()\ntaper=.1\ndesign = c << lumi.mimo(\n    l_design,\n    w_design,\n    east=[w_design-w_wg/4],\n    w_wg=w_wg/2,\n    l_wg=l_wg,\n    layer_wg=WG,\n    layer_design=DESIGN,\n    taper=[(0, taper/2)],\n    init=1,\n)\n\nsource_port=f'o1'\nc.add_port(f'o2', port=design.ports[f'o1'])\n\nif bidirectional:\n    c << gf.components.bbox(component=c, layer=BBOX, top=margin)\nelse:\n    design.movex(-R)\n    c << gf.components.bbox(component=c, layer=BBOX, top=margin,left=margin,)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/opt-pvgc#geometry","position":3},{"hierarchy":{"lvl1":"Perfectly Vertical Grating Coupler (PVGC) Inverse Design","lvl2":"Solve"},"type":"lvl2","url":"/opt-pvgc#solve","position":4},{"hierarchy":{"lvl1":"Perfectly Vertical Grating Coupler (PVGC) Inverse Design","lvl2":"Solve"},"content":"\n\n# layer stack. lower mesh order layers override higher mesh order layers. for 2.5D problems as is here, the mesher will slice thru middle of 'core' layer\nlayers = {\n    \"wg\": LayerLevel(\n        layer=LogicalLayer(layer=WG),\n        zmin=0,\n        thickness=h_wg,\n        material='Si',\n        mesh_order=100,\n    ),\n    \"design\": LayerLevel(\n        layer=LogicalLayer(layer=DESIGN),\n        zmin=h_slab,\n        thickness= d_etch,\n        material=\"design\",\n        mesh_order=1,\n    ),\n}\nlayer_stack = LayerStack(layers=layers)\n\n_dx = λ_SiO2 / nres\nnr = round(R/_dx)\n_dx=R/nr\n\nif bidirectional:\n    x =y= np.linspace(_dx/2,R-_dx/2, nr)\nelse:\n    x = np.linspace(-R+_dx/2,R-_dx/2,2*nr)\n    y = np.linspace(_dx/2,R-_dx/2, nr)\nX, Y = np.meshgrid(x, y, indexing='ij')\ng = np.exp(-(X**2 + Y**2) / (2 * (w/2) ** 2))\n\nwg_mode=lumi.Mode(\n        ports=['o2'],\n        start=[-w_wg/4, -height_port_margin],\n        stop=[w_wg / 4+lateral_port_margin, h_wg + height_port_margin],\n        boundaries=[('PEC','PML'),'PML']\n    )\nif bidirectional:\n    source_mode=lumi.Mode(\n        ports=[source_port],\n         fields={\n            \"Ey\": g,\n            \"Hx\": -g * n_SiO2,\n        },\n        start=[0, 0],\n        stop=[R,R],\n        boundaries=[('PMC','PML'),('PEC','PML')]\n    )\nelse:\n    source_mode=lumi.Mode(\n        ports=[source_port],\n        fields={\n            \"Ey\": g,\n            \"Hx\": -g * n_SiO2,\n        },\n        start=[-R, 0],\n        stop=[R,R],\n        boundaries=['PML',('PEC','PML')]\n    )\nmodes = [wg_mode, source_mode]\n\n\n# additional ports not attached to gdsfactory component\nports = [\n    lumi.PlanePort(\n        name=source_port,\n        origin=[0, 0, z_port],\n        frame=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n    )\n]\n\nsources = [\n    lumi.Source(\n        source_port,\n        wavelength=wavelength,\n        bandwidth=wavelength / 5,\n        source_port_margin=source_port_margin,\n    )\n]\n\ntargets =        [\n            lumi.Target(\n                key=f\"To2@0,{source_port}@0\",\n                target=1,\n                weight=1 / len(wavelengths),\n                wavelength=wl,\n                func=\"relu-\",\n            )\n            for wl in wavelengths        ]\n\ntmax = 1.3 *(\n    ( 6*(h_wg*n_Si+gap2*n_SiO2)+(source_port_margin+gap1)*n_SiO2) \n    + (l_wg +l_design + w_design+R)* n_Si\n) / wavelength\n\nlmin_design = 0.065\ndesigns = [\n    lumi.Design(\n        \"design\",\n        layer=DESIGN,\n        lmin=lmin_design,\n        fill_material='Si',\n        void_material='SiO2',\n        uniform_along=\"z\",\n    ),\n]\n\noptimizer = lumi.Optimizer(\n    stoploss=0.1,\n    # lowloss=0.4,\n    iters=30,  # max iters\n    momentum=0.8,\n    # contrast=1.0,\n)\n\nboundaries = ['PML', ['PEC',\"PML\"], [\"PEC\", \"PML\"]]\nrelative_pml_depths = [.7, 0.3, 0.7]  # relative PML thicknesses in x, y, z\n\nlabels={\n    # 'o1':'λ = 1311nm',\n}\n\nif bidirectional:\n    mirrors=['x-','y-']\nelse:\n    mirrors=['y-']\nviews = [\n    lumi.View(\"Ey\",y=0, z=d_etch / 2 + h_slab,mirrors=mirrors,show_box=False,material_color_intensity=5),\n]\n\nrelative_courant = 0.95\nsaveat = 25  # save frame every `saveat` periods for movie\n\nlumi.make(\n    #\n    path=path,  # path to make problem folder\n    component=c,\n    wavelength=wavelength,\n    wavelengths=wavelengths,\n    ports=ports,\n    modes=modes,\n    sources=sources,\n    boundaries=boundaries,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    zmin=zmin,  # zmin of simulation region\n    zmax=zmax,  # zmax of simulation region\n    #\n    nres=nres,\n    tmax=tmax,  # total simulation time in periods\n    relative_pml_depths=relative_pml_depths,\n    relative_courant=relative_courant,\n    saveat=saveat,\n    #\n    views=views,\n    # inverse design parameters\n    # load_saved_designs=True,\n    designs=designs,\n    targets=targets,\n    optimizer=optimizer,\n)\nraise SystemExit\n\n\n\n\n\n\n\n\n\n\n\n\n\nnres=6\nsaveat=1\nwavelengths=np.linspace(1.5,1.6,101)\ntmax=40\npath0=path\npath=path0+'_final'\nos.system(f'cp -r {path0}/designs/ {path}')\nlumi.make(\n    #\n    path=path,  # path to make problem folder\n    component=c,\n    wavelength=wavelength,\n    wavelengths=wavelengths,\n    ports=ports,\n    modes=modes,\n    sources=sources,\n    boundaries=boundaries,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    zmin=zmin,  # zmin of simulation region\n    zmax=zmax,  # zmax of simulation region\n    #\n    nres=nres,\n    tmax=tmax,  # total simulation time in periods\n    relative_pml_depths=relative_pml_depths,\n    relative_courant=relative_courant,\n    saveat=saveat,\n    #\n    views=views,\n    # inverse design parameters\n    load_saved_designs=True,\n    designs=designs,\n)\nraise SystemExit\n\n\n\nlumi.movie(path,views,1)#,run=False)\n\n\n\n\n\nplt.close()\nsol = lumi.load(path)\nx = wavelengths\n\ny = lumi.query(sol, \"To2@0,o1@0\")  # wavelength or frequency ordered depending on problem setup\ny=[10*np.log10(y) for y in y]\n\nplt.plot(x, y)\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n","type":"content","url":"/opt-pvgc#solve","position":5},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer"},"type":"lvl1","url":"/opt-demux","position":0},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer"},"content":"","type":"content","url":"/opt-demux","position":1},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Overview"},"type":"lvl2","url":"/opt-demux#overview","position":2},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Overview"},"content":"We inverse design a 1x4 wavelength demultiplexer (WDM) in silicon photonics splitting 4 wavelengths spaced 20nm apart into 4 output waveguides. Design region is a 8um x 8um square of silicon surrounded by silica cladding. We use differentiable simulation powered adjoint optimization to aim for high channel transmission while minimizing crosstalk. For sake of speed this is done in 2.5D (differs from 3D by only couple lines in the code).\n\n","type":"content","url":"/opt-demux#overview","position":3},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Geometry"},"type":"lvl2","url":"/opt-demux#geometry","position":4},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Geometry"},"content":"\n\nimport os\nimport math\nimport numpy as np\nimport luminescent as lumi\nimport gdsfactory as gf\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport matplotlib.pyplot as plt\nfrom IPython.display import Image, display\n\n\n# folder for saving config and results\npath = os.path.join(\"runs\", \"demux\")\n\nwavelength = 1.3  # characteristic wavelength\nwavelengths = 1.27, 1.29, 1.31, 1.33\n\n# layers\nWG = (1, 0)  # waveguide layer\nCLAD = (2, 0)  # cladding layer\nDESIGN = (100, 0)  # design region layer\n\n# makes gdsfactory component to be optimized. has rectangular design region with port stubs. ports numbered clockwise from bottom left\nlength = 6.0\nwidth = 6.0\nw_wg = 0.4\nl_wg = 3 * w_wg\nc = gf.Component()\ndut = lumi.mimo(\n    length,\n    width,\n    west=1,\n    east=4,\n    w_wg=w_wg,\n    l_wg=l_wg,\n    init=1,  # solid slab\n    layer_wg=WG,\n    layer_design=DESIGN,\n)\n# metadata. here we include design region info containing port locations useful for loading the optimized component after optimization\ninfo = {\"designs\": [{\"ports\": dut.info.ports}]}\ndut = c << dut\n\n# margin extensions\nlateral_port_margin = height_port_margin = 0.4\nxmargin = 1.5 * lateral_port_margin\nzmargin = 1.5 * height_port_margin\nsource_port_margin = 1.0 * (w_wg + 2 * lateral_port_margin)\next = c << gf.components.straight(source_port_margin, width=w_wg)\next.connect(\"o2\", dut.ports[\"o1\"])\n\n# add ports\nfor i in range(1, 6):\n    c.add_port(f\"o{i}\", port=dut.ports[f\"o{i}\"])\n\nc << gf.components.bbox(component=c, layer=CLAD, top=xmargin, bottom=xmargin)\nc.plot()\n\n\n\n","type":"content","url":"/opt-demux#geometry","position":5},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Solve"},"type":"lvl2","url":"/opt-demux#solve","position":6},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Solve"},"content":"\n\n# layer stack. lower mesh order layers override higher mesh order layers. for 2.5D problems as is here, the mesher will slice thru middle of 'core' layer\nthickness = 0.22\nmaterials_library = lumi.MATERIALS_LIBRARY\nnSi = math.sqrt(materials_library[\"Si\"][\"epsilon\"])\nmaterials_library.update(\n    {\n        \"design\": lumi.PlaceholderMaterial(mesh_density=nSi),  # placeholder material for design region\n        \"background\": materials_library[\"SiO2\"],\n    }\n)\n\nlayer_stack = LayerStack(\n    layers={\n        \"design\": LayerLevel(\n            layer=LogicalLayer(layer=DESIGN),\n            thickness=thickness,\n            zmin=0.0,\n            material=\"design\",\n            mesh_order=0,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=thickness,\n            zmin=0.0,\n            material=\"Si\",\n            mesh_order=1,\n        ),\n    }\n)  \n\n# time [periods at characteristic wavelength ]\nTsim = (source_port_margin + 2 * l_wg + 4 * (length + width)) / wavelength * nSi\n\n# each mode will be solved for sources and monitors\nmodes = [lumi.Mode(wavelength=wavelength)]\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n        wavelength=wavelength,\n        bandwidth=0.2,\n    )\n]\ndesigns = [\n    lumi.Design(\n        name=\"d1\",\n        layer=DESIGN,\n        lmin=0.15,\n        fill_material=\"Si\",\n        void_material=\"SiO2\",\n    )\n]\n# optimization targets of Tsim params.\n# o1@0 means optical port 1 on mode 0 (fundamental mode)\ntargets = [\n    lumi.Target(\n        key=f\"To{i+2}@0,o1@0\",\n        target=1.0,\n        weight=1 / 4,\n        wavelength=wl,\n    )\n    for i, wl in enumerate(wavelengths)\n]\n\noptimizer = lumi.Optimizer(stoploss=0.1, iters=50,momentum=.8)\n\nkwargs = dict(\n    path=path,  # path to make problem folder\n    component=c,\n    wavelengths=wavelengths,\n    wavelength=wavelength,\n    modes=modes,\n    info=info,\n    sources=sources,\n    #\n    lateral_port_margin=lateral_port_margin,\n    height_port_margin=height_port_margin,\n    zmin=-zmargin,\n    zmax=thickness + zmargin,\n    #\n    materials_library=materials_library,\n    layer_stack=layer_stack,\n    #\n    gpu=\"CUDA\",\n    nres=6,  # number of grid points per wavelength in material (not vacuum)\n    relative_courant=0.9,\n    Tsim=Tsim,\n    force=True,  # overwrite files in existing path\n    #\n    approx_2D_mode=\"TE\",  # makes problem 2.5D instead of 3D\n    z=thickness / 2,  # z coordinate to slice the 2.5D problem at\n    #\n    designs=designs,\n    targets=targets,\n    optimizer=optimizer,\n)\nlumi.make(**kwargs)\nlumi.solve(path)\ndisplay(Image(filename=os.path.join(path, \"peak.png\")))\nlumi.plot(path)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/opt-demux#solve","position":7},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Post optimization simulation"},"type":"lvl2","url":"/opt-demux#post-optimization-simulation","position":8},{"hierarchy":{"lvl1":"Inverse design of photonic wavelength division demultiplexer","lvl2":"Post optimization simulation"},"content":"\n\n# new simulation with optimized design and finer spaced wavelengths\ndel kwargs['targets']\ndel kwargs['optimizer']\nwavelengths1=np.linspace(1.26, 1.34, 81)\nkwargs.update(\n    wavelengths=wavelengths1,\n    load_saved_designs=True)\nlumi.make(**kwargs)\nlumi.solve(path)\n\n\n\n\n\n\n\n\n\nsol = lumi.load(path)\nx = wavelengths1\nys = [lumi.query(sol, f\"To{i}@0,o1@0\") for i in range(2, 6)]\nplt.figure()\nfor y in ys:\n    plt.plot(x, [10*math.log10( y) for y in y])\nplt.scatter(wavelengths, [0]*len(wavelengths), 100, marker=\"*\")\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"transmission [dB]\")\nplt.show()\n\n\n\n","type":"content","url":"/opt-demux#post-optimization-simulation","position":9},{"hierarchy":{"lvl1":"Photonic PDK"},"type":"lvl1","url":"/pdk","position":0},{"hierarchy":{"lvl1":"Photonic PDK"},"content":"Lumi Photonic PDK (process design kit) is a library of AI inverse designed photonic components for PIC (photonic integrated circuit). Unlike a traditional PDK, each component here is more akin to a reference design that shows what’s possible. In most cases, they should be re-optimized for your specific needs and process node. We can inverse design for any S-parameters objective with any geometry, wavelength, polarization, and layer stack.","type":"content","url":"/pdk","position":1},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Perfectly vertical grating coupler (PVGC)"},"type":"lvl2","url":"/pdk#perfectly-vertical-grating-coupler-pvgc","position":2},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Perfectly vertical grating coupler (PVGC)"},"content":"Flexible, tolerant, perfectly vertical coupling between PIC and fiber / VCSEL / EEL / PD. Can inverse design for any modal profile. Sinble output design is compact and narrowband. Bidirectional design offers superior loss bandwidth tradeoff and is suited for broadband multiplexing applications. Below are sample designs for standard SMF-28 fiber mode at 1550nm wavelength.","type":"content","url":"/pdk#perfectly-vertical-grating-coupler-pvgc","position":3},{"hierarchy":{"lvl1":"Photonic PDK","lvl3":"Single output PVGC","lvl2":"Perfectly vertical grating coupler (PVGC)"},"type":"lvl3","url":"/pdk#single-output-pvgc","position":4},{"hierarchy":{"lvl1":"Photonic PDK","lvl3":"Single output PVGC","lvl2":"Perfectly vertical grating coupler (PVGC)"},"content":"Loss: ~0.3dB (simulated)Bandwidth (1dB): ~10nm","type":"content","url":"/pdk#single-output-pvgc","position":5},{"hierarchy":{"lvl1":"Photonic PDK","lvl3":"Narrowband Bidirectional PVGC","lvl2":"Perfectly vertical grating coupler (PVGC)"},"type":"lvl3","url":"/pdk#narrowband-bidirectional-pvgc","position":6},{"hierarchy":{"lvl1":"Photonic PDK","lvl3":"Narrowband Bidirectional PVGC","lvl2":"Perfectly vertical grating coupler (PVGC)"},"content":"Loss: ~0.1dB (simulated)Bandwidth (1dB): ~10nm","type":"content","url":"/pdk#narrowband-bidirectional-pvgc","position":7},{"hierarchy":{"lvl1":"Photonic PDK","lvl3":"Broadband Bidirectional PVGC","lvl2":"Perfectly vertical grating coupler (PVGC)"},"type":"lvl3","url":"/pdk#broadband-bidirectional-pvgc","position":8},{"hierarchy":{"lvl1":"Photonic PDK","lvl3":"Broadband Bidirectional PVGC","lvl2":"Perfectly vertical grating coupler (PVGC)"},"content":"Bandwidth (1dB): ~60nm\nBandwidth (3dB): ~100nm","type":"content","url":"/pdk#broadband-bidirectional-pvgc","position":9},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"MMI aka splitters and combiners"},"type":"lvl2","url":"/pdk#mmi-aka-splitters-and-combiners","position":10},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"MMI aka splitters and combiners"},"content":"MMIs with arbitrary split ratios and ports are easily inverse designed.","type":"content","url":"/pdk#mmi-aka-splitters-and-combiners","position":11},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Wavelength domain multiplexer (WDM)"},"type":"lvl2","url":"/pdk#wavelength-domain-multiplexer-wdm","position":12},{"hierarchy":{"lvl1":"Photonic PDK","lvl2":"Wavelength domain multiplexer (WDM)"},"content":"Compact wavelength domain multiplexer and demultiplexer with low insertion loss and crosstalk.\n\nUpdating... Please check back mid January","type":"content","url":"/pdk#wavelength-domain-multiplexer-wdm","position":13},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"type":"lvl1","url":"/test-fss","position":0},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"content":"","type":"content","url":"/test-fss","position":1},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"type":"lvl2","url":"/test-fss#overview","position":2},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"content":"We simulate microwave frequency selective surface (FSS) with 12GHz bandstop. periodic Metal cross array on dielectric substrate. Compare with Tidy3D example \n\nhttps://​www​.flexcompute​.com​/tidy3d​/examples​/notebooks​/MicrowaveFrequencySelectiveSurface\n\n","type":"content","url":"/test-fss#overview","position":3},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"type":"lvl2","url":"/test-fss#geometry","position":4},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport math\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# simulation folder\nstudy='microwave_frequency_selective_surface'\npath = os.path.join('studies', study)\n\n# length and frequency units are arbitrary\nfrequency = 12  # origin frequency GHz\nbw = 4  # bandwidth\ndf = 0.05  # frequency step\nwl1f = 300  # vacuum wavelength at 1 unit of frequency in your units\nwl = wl1f / frequency  # characteristic wavelength\nfrequencies = np.linspace(frequency-bw/2, frequency+bw/2, round(bw/df+1))\n\n# unit cell [mm]\nP = 15  # periodicity\nL = 9.4  # length of cross\nW = 2.0  # width of cross stub\nd = 2.2  # height of substrate\nth = 0.1  # metal thickness\ngap = 30.0  # air gap below and above - keeps resonant evanescent field from coupling to lossy PML\nmargin = 2.0\n\n# adaptive meshing\ndx=W/5  # desired spatial resolution\nnres = 16\ndx0 = wl / nres\nmesh_density = dx0 /dx\n\n# material_library\nmaterial_library = lumi.MATERIAL_LIBRARY\nmaterial_library[\"sub\"] = lumi.Material(epsilon=2.5, mesh_density=mesh_density)\nmaterial_library[\"PEC\"] = lumi.PECMaterial(mesh_density=mesh_density)\n\n# make geometry in gdsfactory. 1/4 section of unit cell due to symmetry\n# alternatively can import .gds into gdsfactory\n\nWG = (1, 0)\nBBOX = (2, 0)\n\nlayer_stack = LayerStack(\n    layers={\n        \"WG\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=th,\n            zmin=0,\n            material=\"PEC\",\n            mesh_order=1,\n        ),\n        \"sub\": LayerLevel(\n            layer=LogicalLayer(layer=BBOX),\n            thickness=d,\n            zmin=-d,\n            material=\"sub\",\n            mesh_order=2,\n        ),\n    }\n)\n\nc = gf.Component()\nc.add_polygon(\n    [(0, 0), (0, L / 2), (W / 2, L / 2), (W / 2, 0)],\n    layer=WG,\n)\np = c.add_polygon(\n    [(W / 2, W / 2), (W / 2, 0), (L / 2, 0), (L / 2, W / 2)],\n    layer=WG,\n)\nc.add_polygon([(0, 0), (0, P / 2), (P / 2, P / 2), (P / 2, 0)], layer=BBOX)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-fss#geometry","position":5},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Problem"},"type":"lvl2","url":"/test-fss#problem","position":6},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Problem"},"content":"\n\n\n\n\n\nxc = P / 4\nyc = P / 4\nports = [\n    lumi.PlanePort(\n        name='o1',\n        origin=[xc, yc, th + gap],\n        frame=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n    ),\n    lumi.PlanePort(\n        name='o2',\n        origin=[xc, yc, -d- gap],\n        frame=[[-1, 0, 0], [0, 1, 0], [0, 0, -1]],\n    ),\n]\n\nnx=ny=round(P/2/dx)\na=np.ones((nx,ny))\nmodes = [lumi.Mode(\n    frequencies=[frequency],\n    fields=[[{\"Ex\": a, \"Hy\": a},{\"Ey\": a, \"Hx\": -a}]],\n    start=[-P/4, -P/4],\n    stop=[P/4, P/4],\n    )]\n\nsources = [lumi.Source(\"o1\", source_port_margin=margin, frequency=frequency, bandwidth=bw)]\n\nviews=[lumi.View('Ex',x=0,y=0,z=th/2)]\n\n# Luminescent community cloud client\nemail=____# replace with your registered email\nclient=lumi.Client(email,cloud='luminescent_community_cloud')\n\nlumi.make(\n    path,\n    component=c,\n    frequencies=frequencies,\n    wl1f=wl1f,\n    # antisymmetric/PEC/odd vs symmetric/PMC/even symmetry\n    boundaries=[\"PEC\", \"PMC\", \"PML\"],\n    #\n    sources=sources,\n    ports=ports,\n    modes=modes,\n    zmin=-gap-d,\n    zmax= th + gap + margin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    nres=nres,\n    tmax=50,  # max time [periods]\n    energy_decay_threshold=0.001,  # field decay threshold for stopping simulation\n    saveat=1,\n    # visualization\n    views=views,\n    # \n    client=client,\n)\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-fss#problem","position":7},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Movie"},"type":"lvl2","url":"/test-fss#movie","position":8},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Movie"},"content":"\n\nlumi.movie(path)\n\n\n\n\n\n","type":"content","url":"/test-fss#movie","position":9},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"type":"lvl2","url":"/test-fss#analysis","position":10},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = [10 * math.log10(x) for x in lumi.query(sol,'T2,1')]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n","type":"content","url":"/test-fss#analysis","position":11},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"type":"lvl1","url":"/test-ring","position":0},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"content":"","type":"content","url":"/test-ring","position":1},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"type":"lvl2","url":"/test-ring#overview","position":2},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"content":"We simulate small silicon ring resonator coupled to parallel waveguides buried in silica cladding. We use midplane z PMC symmetry to slash cell count by half.\n\n","type":"content","url":"/test-ring#overview","position":3},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"type":"lvl2","url":"/test-ring#geometry","position":4},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# simulation folder \nstudy='photonic_ring_resonator'\npath = os.path.join('studies', study)\n\n# length units are arbitrary so long as they are consistent, in this case [um]. everything gets normalized around origin wavelength and period at backend.\nwavelength = 1.55  # characteristic wavelength [um]\nbandwidth = 0.1  # wavelength bandwidth [um]\nwavelengths = np.linspace(wavelength - bandwidth / 2, wavelength + bandwidth / 2, 401)\n\nr = 3.1  # radius of ring\nw_wg = 0.4  # width of waveguide\ngap = 0.1  # gap between waveguide and ring\nh_wg = 0.18  # h_wg of waveguide\n\n# gds layers\nWG = (1, 0)  # waveguide layer\nBBOX = (10, 0)  # bounding box layer\n\n# we create geometry in gdsfactory. alternatively, you can import .gds layout into gdsfactory or .stl bodies directly into ours\n\n# margins\nheight_port_margin = lateral_port_margin = 0.8\nmargin = 1.2 * lateral_port_margin\nzmargin = 1.2 * height_port_margin\nsource_port_margin = 1.0 * (w_wg + 2 * lateral_port_margin)\n\n# draw layout in gdsfactory. `gf.components` defaults to layer WG = (1, 0)\nc = gf.Component()\n\ndut = c << gf.components.ring(radius=r, width=w_wg, layer=WG)\n\nl_branch = 2 * r + w_wg + source_port_margin + 2*margin\nxoffset = -source_port_margin - margin - r - w_wg / 2\nyoffset = w_wg + gap + r\nbranch_top = c << gf.components.straight(length=l_branch, width=w_wg)\nbranch_top.move((xoffset, w_wg + gap + r))\n\nbranch_bottom_left = c << gf.components.straight(length=source_port_margin, width=w_wg)\nbranch_bottom_left.move((xoffset, -yoffset))\n\nbranch_bottom_right = c << gf.components.straight(length=l_branch - source_port_margin, width=w_wg)\nbranch_bottom_right.connect(\"o1\", branch_bottom_left.ports[\"o2\"])\n\n\n# add ports\nc.add_port(\"o1\", port=branch_bottom_right.ports[\"o1\"])\nc.add_port(\"o2\", port=branch_bottom_right.ports[\"o2\"])  # thru channel\nc.add_port(\"o3\", port=branch_top.ports[\"o1\"])  # drop channel\n\nc << gf.components.bbox(component=c, layer=BBOX, top=margin, bottom=margin)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-ring#geometry","position":5},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"type":"lvl2","url":"/test-ring#solve","position":6},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"content":"\n\n# for gdsfactory, we need vertical layer stack. \"core\" layer is special as `height_port_margin` are demarcated from it for defining modal sources and monitors. during 3d meshing lower mesh order layers supplant higher mesh order layers\nlayer_stack = LayerStack(\n    layers={\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=h_wg/2,\n            zmin=0.0,\n            material=\"Si\",\n            mesh_order=10,\n        ),\n    }\n)\n\n# our default lumi.MATERIAL_LIBRARY lib covers limited range of photonic and PCB material_library. here we create our own material_library. `background` is special and tags regions outside any bodies during meshing\nmaterial_library = {\n    \"Si\": lumi.Material(epsilon=12.25),\n    \"SiO2\": lumi.Material(epsilon=2.25),\n}\nmaterial_library[\"background\"] = material_library[\n    \"SiO2\"\n]  \n\n# source launches `source_port_margin` in front of port. it's bidirectional: the other direction goes into PML. pulse spectrum rolls off gradually past bandwidth limits.\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n        wavelength=wavelength,\n        bandwidth=wavelength/5,\n        modenums=[0],  # fundamental mode only\n    )\n]\n\nlx = w_wg + 2 * lateral_port_margin\nly = h_wg + 2 * height_port_margin\nmodes = [\n    lumi.Mode(\n        wavelengths=np.linspace(wavelengths[0], wavelengths[-1],5),\n        start=[-lx / 2, 0],  # local xy frame\n        stop=[lx / 2, h_wg/2 + height_port_margin],\n        boundaries=['PML',('PMC','PML')]\n    )\n]\n\n# Luminescent community cloud client\nemail=____ # replace with your registered email\nclient=lumi.Client(email,cloud='luminescent_community_cloud')\n\nlumi.make(\n    path=path,\n    component=c,\n    wavelengths=wavelengths,\n    sources=sources,\n    modes=modes,\n    # limits\n    boundaries=['PML','PML',('PMC','PML')], # z midplane PMC symmetry\n    zmin=0,\n    zmax=h_wg/2 + zmargin,\n    # materials and layers\n    material_library=material_library,\n    layer_stack=layer_stack,\n    # accuracy and speed settings\n    nres=8,  # number of grid points per wavelength in material (not vacuum)\n    relative_courant=0.95,  # relative to maximum theoretical Courant number at\n    relative_pml_depths=[1, 1, 0.25],  \n    tmax=1000,  # max time [periods]\n    energy_decay_threshold=0.001,  # field energy decay threshold for stopping simulation\n    saveat=25,  # save and plot field every _ periods, involves slow disk write\n    # visualization\n    views=[lumi.View(\"Hz\",x=0,y=0,z=0)],\n    # \n    client=client,\n)\n\n\n\n\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-ring#solve","position":7},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"type":"lvl2","url":"/test-ring#visualize","position":8},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"content":"\n\n\n\nlumi.movie(path) # full movie - this may take a while to generate\n\n\n\n\n\n","type":"content","url":"/test-ring#visualize","position":9},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"type":"lvl2","url":"/test-ring#analysis","position":10},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = wavelengths\n\n# S or T params. wavelength or frequency ordered depending on problem setup\ny = lumi.query(sol, \"To3@0,o1@0\")  # same as y=np.abs2(sol['waves']['o3@0+']/sol['waves']['o1@0-'])\n# y = lumi.query(sol, \"T3,1\") # flux\n\nplt.plot(x, y)\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"drop channel transmitted power\")\nplt.show()\n\n\n\n","type":"content","url":"/test-ring#analysis","position":11},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"type":"lvl1","url":"/test-stub","position":0},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"content":"","type":"content","url":"/test-stub","position":1},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"type":"lvl2","url":"/test-stub#overview","position":2},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"content":"We simulate a quarter wave stub bandstop filter in RF microstrip with nominal 5GHz notch.\n\n","type":"content","url":"/test-stub#overview","position":3},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"type":"lvl2","url":"/test-stub#geometry","position":4},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# simulation folder \nstudy='microstrip_stub_filter'\npath = os.path.join('studies', study)\n\n# length and frequency units are arbitrary but must be consistent. here we use mm and GHz\nfrequency = 5  # characteristic frequency in GHz\nfrequencies = np.linspace(3, 7, 81).tolist()\nwl1f = 300  # vacuum wavelength at 1 unit of frequency, all in your units\nwavelength = wl1f / frequency  # characteristic wavelength\nbandwidth = max(frequencies) - min(frequencies)\n\n# microstrip\nw_line = 1.52  # mm\nth = 0.035  # mm\nd = 0.8  # mm\nc = 87.5 / 139  # relative signal speed, from microstrip calculator\n\nwl_sig = wl1f * c / frequency  # wavelength in the signal line\nl_stub = wl_sig / 4 # quarter-wave stub length\nl_feed = 1 * l_stub\nlateral_port_margin = height_port_margin = 2 * d\nmargin = zmargin = 1.25 * lateral_port_margin\nlx_mode = w_line + 2 * lateral_port_margin  # lateral size of mode region\nsource_port_margin = 1.5 * (w_line + 2 * lateral_port_margin)\n\n# layers\nFEED = 1, 0\nSTUB = 2, 0\nSUB = 10, 0\n\n# make geometry in gdsfadory\n# alternatively can import .gds into gdsfadory\nc = gf.Component()\nfeed = c << lumi.straight(length=l_feed, width=w_line, layer=FEED)\nstub = c << lumi.straight(length=l_stub, width=w_line, layer=STUB)\nstub.rotate(90)\nstub.movex(l_feed / 2)\next = c << lumi.straight(source_port_margin, width=w_line, layer=FEED)\next.connect(\"o2\", feed.ports[\"o1\"])\n\nfor i in (1, 2):\n    c.add_port(f\"o{i}\", port=feed.ports[f\"o{i}\"])\n\nc << gf.components.bbox(component=c, layer=SUB, top=margin, bottom=margin)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-stub#geometry","position":5},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"type":"lvl2","url":"/test-stub#solve","position":6},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"content":"\n\n# adaptive meshing\nnres = 16\ndx0 = wavelength / nres\n\nlayer_stack = LayerStack(\n    layers={\n        \"feed\": LayerLevel(\n            layer=LogicalLayer(layer=FEED),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=10,\n        ),\n        \"stub\": LayerLevel(\n            layer=LogicalLayer(layer=STUB),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=20,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=SUB),\n            zmin=-d,\n            thickness=d,\n            material=\"sub\",\n            mesh_order=30,\n        ),\n    }\n)\n\n# materials\neps_sub = 4.3\nn_sub = np.sqrt(eps_sub)\n\ndx = w_line / 4  # 4 mesh points across the strip\nn_PEC = dx0 / (dx)  # mesh density relative to vacuum\n\nmaterial_library = {\n    \"sub\": lumi.Material(epsilon=eps_sub),\n    \"PEC\": lumi.PECMaterial(mesh_density=n_PEC),\n}\nmaterial_library[\"background\"] = lumi.Material(epsilon=1.0)\n\n_dx=dx \n_dy=th\nmodes = [\n    lumi.Mode(\n        ports=[\"o1\", \"o2\"],\n        frequencies=[frequency],\n        metallic_boundaries=[\"y-\", \"feed\"],\n        nmodes=1,\n        start=[-lx_mode/2, -d], # local xy frame, local y=0 at global zmin of port layer\n        stop=[lx_mode/2, th + height_port_margin],\n        voltage_line=[(0, -d), (0, 0)], # optional\n        current_loop=[\n            (-w_line / 2 - _dx,  - _dy),\n            (-w_line / 2 - _dx,  th + _dy),\n            (w_line / 2 + _dx,  th + _dy),\n            (w_line / 2 + _dx,  - _dy),\n        ], # optional\n    )\n]\n\nsources = [\n    lumi.Source(\n        \"o1\", frequency=frequency, duration=0.5, source_port_margin=source_port_margin\n    ) # modulated Gaussian pulse\n]\n\nviews=[\n        lumi.View(\"Ez\", x=-source_port_margin, y=0, z=-d / 2),\n        lumi.View(\"Hz\", z=th / 2),\n    ]\n \n# Luminescent community cloud client\nemail=____# replace with your registered email\nclient=lumi.Client(email,cloud='luminescent_community_cloud')\n\nlumi.make(\n    path=path,\n    component=c,\n    frequency=frequency, # characteristic frequency\n    frequencies=frequencies,\n    wl1f=wl1f,\n    sources=sources,\n    modes=modes,\n    # bounds\n    boundaries=[\"PML\", \"PML\", [\"PEC\", \"PML\"]],\n    zmin=-d,\n    zmax=th + zmargin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    # performance\n    nres=nres,\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    relative_pml_depths=[1, 0.3, 0.3],\n    energy_decay_threshold=0.01,  # field decay threshold for stopping simulation\n    saveat=1,  # save frame for plotting every _ periods\n    # visualization\n    views=views,\n    # \n    client=client,\n)\n\n\n\n\n\n\n\n\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-stub#solve","position":7},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"type":"lvl2","url":"/test-stub#visualize","position":8},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"content":"\n\nlumi.movie(path)\n\n\n\n\n\n","type":"content","url":"/test-stub#visualize","position":9},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"type":"lvl2","url":"/test-stub#analysis","position":10},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = lumi.query(sol, \"To2,o1\") # convenience function for T-parameters using modal decomposition\n\n# S-parameters can also be computed explicitly from complex valued modal or voltage waves:\n# y = np.abs2(sol[\"waves\"][\"o2@0+\"] / sol[\"waves\"][\"o1@0-\"]) # explicit T21 using forward/backward modal amplitudes\n# y = np.abs2(sol[\"waves\"][\"o2+\"] / sol[\"waves\"][\"o1-\"]) # using forward/backward voltage waves\n\ny = [10 * np.log10(v) for v in y]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n\n\ny=377*sol['Z']['o1']\nplt.plot(x,np.real(y),label=\"Real\",color='orange')\nplt.plot(x,np.imag(y),label=\"Imaginary\",color='blue')\nplt.xlabel(\"f [GHz]\")\nplt.ylabel('complex line impedance [Ohms]')\nplt.legend()\nplt.show()\n\n","type":"content","url":"/test-stub#analysis","position":11}]}