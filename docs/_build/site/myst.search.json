{"version":"1","records":[{"hierarchy":{"lvl1":"Home"},"type":"lvl1","url":"/features","position":0},{"hierarchy":{"lvl1":"Home"},"content":"v2.1 2025-10-30","type":"content","url":"/features","position":1},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"type":"lvl2","url":"/features#overview","position":2},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"content":"Luminescent AI enables generative design and simulation of electromagnetic structures  in just a few lines of code! We help design next generation photonic integrated circuits, optical metasurfaces, RF and microwave circuits, and antennas in diverse industries including consumer electronics, automotive, telecom, datacenters and quantum computing. At the heart is our fully differentiable and GPU-accelerated finite difference time domain (FDTD) engine.","type":"content","url":"/features#overview","position":3},{"hierarchy":{"lvl1":"Home","lvl2":"Features"},"type":"lvl2","url":"/features#features","position":4},{"hierarchy":{"lvl1":"Home","lvl2":"Features"},"content":"Powerful\n\nGenerative inverse design and simulation in just few lines of Python code!\n\nBroadband and multimode S-parameters\n\nEmbedded mode solver for modal sources and monitors\n\n.gds and gdsfactory integration\n\n.stl / .step  3D geometry import\n\nSmart\n\nFully differentiable (native automatic differentiation in Julia)\n\nSimultaneous inverse design of multiple 2D and 3D structures\n\nLength scale controlled geometry optimizer with fabrication constraints\n\nFast\n\nGPU acceleration on NVIDIA, AMD, and Apple Silicon\n\nAdaptive graded mesh reduces cell count\n\nTensor subpixel smoothing boosts accuracy\n\nComprehensive\n\nModal sources, plane waves, Gaussian beams, custom sources\n\nOblique sources and monitors\n\nPML, periodic, PEC, PMC boundaries\n\nNear and far field radiation patterns\n\nNonlinear, dispersive and anisotropic materials","type":"content","url":"/features#features","position":5},{"hierarchy":{"lvl1":"Home","lvl2":"Aboout"},"type":"lvl2","url":"/features#aboout","position":6},{"hierarchy":{"lvl1":"Home","lvl2":"Aboout"},"content":"We’re Stanford alum and founded Luminescent AI in 2024 to democratize photonic and RF design with AI.\n\nLinkedIn: follow us for product updates and opportunities!\n\nCompany: learn more about our mission and team!Email: \n\npaul@luminescentai​.comWhatsApp and WeChat: +1 (650) 776-7724","type":"content","url":"/features#aboout","position":7},{"hierarchy":{"lvl1":"Home"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Home"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"type":"lvl2","url":"/#overview","position":2},{"hierarchy":{"lvl1":"Home","lvl2":"Overview"},"content":"Luminescent AI harnesses physics grounded AI for designing electromagnetic structures in photonics and RF. We offer Lumi FDTD for full wave simulations and inverse design, and Lumi Photonic PDK of inverse designed photonic components.","type":"content","url":"/#overview","position":3},{"hierarchy":{"lvl1":"Home","lvl2":"Aboout"},"type":"lvl2","url":"/#aboout","position":4},{"hierarchy":{"lvl1":"Home","lvl2":"Aboout"},"content":"We’re Stanford alum and founded Luminescent AI in 2025 to democratize photonic and RF design with AI.\n\nLinkedIn: follow us for updates and opportunities!\n\nWebsite\nEmail: \n\npaul@luminescentai​.comWhatsApp and WeChat: +1 (650) 776-7724","type":"content","url":"/#aboout","position":5},{"hierarchy":{"lvl1":"Installation"},"type":"lvl1","url":"/install","position":0},{"hierarchy":{"lvl1":"Installation"},"content":"Please fill out \n\nnew user form to obtain install scripts for unrestricted simulation. Doesn’t include inverse design.","type":"content","url":"/install","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/pdk","position":0},{"hierarchy":{"lvl1":""},"content":"","type":"content","url":"/pdk","position":1},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"type":"lvl1","url":"/test-fss","position":0},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)"},"content":"","type":"content","url":"/test-fss","position":1},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"type":"lvl2","url":"/test-fss#overview","position":2},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Overview"},"content":"We simulate microwave frequency selective surface (FSS) with 12GHz bandstop. periodic Metal cross array on dielectric substrate. Compare with Tidy3D example \n\nhttps://​www​.flexcompute​.com​/tidy3d​/examples​/notebooks​/MicrowaveFrequencySelectiveSurface\n\n","type":"content","url":"/test-fss#overview","position":3},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"type":"lvl2","url":"/test-fss#geometry","position":4},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport math\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\nname = \"microwave_frequency_selective_surface\"\npath = os.path.join(\"runs\", name)\n\n# length and frequency units are arbitrary\nfrequency = 12  # origin frequency GHz\nbw = 4  # bandwidth\ndf = 0.05  # frequency step\nwl1f = 300  # vacuum wavelength at 1 unit of frequency in your units\nwl = wl1f / frequency  # characteristic wavelength\nfrequencies = np.linspace(frequency-bw/2, frequency+bw/2, round(bw/df+1))\n\n# unit cell [mm]\nP = 15  # periodicity\nL = 9.4  # length of cross\nW = 2.0  # width of cross stub\nd = 2.2  # height of substrate\nth = 0.1  # metal thickness\ngap = 15.0  # air gap below and above - keeps resonant evanescent field from coupling to lossy PML\nmargin = 2.0\n\n# adaptive meshing\nnres = 16\ndx0 = wl / nres\nmesh_density = dx0 / 0.5\n\n# material_library\nmaterial_library = lumi.MATERIAL_LIBRARY\nmaterial_library[\"sub\"] = lumi.Material(epsilon=2.5, mesh_density=mesh_density)\nmaterial_library[\"PEC\"] = lumi.PECMaterial(mesh_density=mesh_density)\n\n# make geometry in gdsfactory. 1/4 section of unit cell due to symmetry\n# alternatively can import .gds into gdsfactory\n\nWG = (1, 0)\nBBOX = (2, 0)\n\nlayer_stack = LayerStack(\n    layers={\n        \"WG\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=th,\n            zmin=0,\n            material=\"PEC\",\n            mesh_order=1,\n        ),\n        \"sub\": LayerLevel(\n            layer=LogicalLayer(layer=BBOX),\n            thickness=d,\n            zmin=-d,\n            material=\"sub\",\n            mesh_order=2,\n        ),\n    }\n)\n\nc = gf.Component()\nc.add_polygon(\n    [(0, 0), (0, L / 2), (W / 2, L / 2), (W / 2, 0)],\n    layer=WG,\n)\np = c.add_polygon(\n    [(W / 2, W / 2), (W / 2, 0), (L / 2, 0), (L / 2, W / 2)],\n    layer=WG,\n)\nc.add_polygon([(0, 0), (0, P / 2), (P / 2, P / 2), (P / 2, 0)], layer=BBOX)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-fss#geometry","position":5},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Solve"},"type":"lvl2","url":"/test-fss#solve","position":6},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Solve"},"content":"\n\nports = [\n    lumi.PlanePort(name=\"o1\", z=th + gap, direction=\"+\"),\n    lumi.PlanePort(name=\"o2\", z=-d-gap, direction=\"-\"),\n]\nmodes = [lumi.Mode(frequencies=[frequency],fields=[[{\"Ex\": 1, \"Hy\": 1},{\"Ey\": 1, \"Hx\": -1}]])]\nsources = [lumi.Source(\"o1\", source_port_margin=margin, frequency=frequency, bandwidth=bw)]\n\nlumi.make(\n    path,\n    name=name,\n    component=c,\n    frequencies=frequencies,\n    wl1f=wl1f,\n    # antisymmetric/PEC/odd vs symmetric/PMC/even symmetry\n    boundaries=[\"PEC\", \"PMC\", \"PML\"],\n    #\n    sources=sources,\n    ports=ports,\n    modes=modes,\n    zmin=-gap-d,\n    zmax= th + gap + margin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    gpu=\"CUDA\",  # use GPU acceleration\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    nres=nres,\n    Tsim=50,  # max time [periods]\n    field_decay_threshold=0.003,  # field decay threshold for stopping simulation\n    saveat=0.25,\n)\nlumi.solve(path)\n\n\n\nviews=[lumi.View('Ex',x=0,y=0,z=th/2)]\nlumi.movie(path, views)\n\n\n\n\n\n","type":"content","url":"/test-fss#solve","position":7},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"type":"lvl2","url":"/test-fss#analysis","position":8},{"hierarchy":{"lvl1":"Metasurface: microwave frequency selective surface (FSS)","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = [10 * math.log10(x) for x in lumi.query(sol,'T2,1')]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n","type":"content","url":"/test-fss#analysis","position":9},{"hierarchy":{"lvl1":"Photonic waveguide bend"},"type":"lvl1","url":"/test-bend","position":0},{"hierarchy":{"lvl1":"Photonic waveguide bend"},"content":"We compute wavelength dependent S-parameters for a photonic waveguide bend in SOI\n\n","type":"content","url":"/test-bend","position":1},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Geometry"},"type":"lvl2","url":"/test-bend#geometry","position":2},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\n# simulation folder\nname='photonic_waveguide_bend'\npath = os.path.join(\"runs\", name)\n\n# length units are arbitrary so long as they're consistent\nwavelength = 1.55 # characteristic wavelength in microns\nwavelengths = np.linspace(1.4, 1.7, 81)\nd = 0.22\nw_wg = 0.5\n\n# layers\nWG = 1, 0\nCLAD = 2, 0\n\n# margins\nlateral_port_margin = height_port_margin = 0.6\nxmargin = 1.25 * lateral_port_margin\nzmargin = 1.25 * height_port_margin\nsource_port_margin = 2 * (w_wg + 2 * lateral_port_margin)\n\n# make component in gdsfactory. alternatively can import .gds into gdsfactory\nc = gf.Component()\n\ndut = c << gf.components.bend_circular(5)\next = c << gf.components.straight(length=source_port_margin)\next.connect(\"o2\", dut.ports[\"o1\"])\n\nc << gf.components.bbox(component=c, layer=CLAD, right=xmargin, bottom=xmargin)\n\nc.add_port(\"o1\", port=dut.ports[\"o1\"])\nc.add_port(\"o2\", port=dut.ports[\"o2\"])  # thru channel\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-bend#geometry","position":3},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Solve"},"type":"lvl2","url":"/test-bend#solve","position":4},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Solve"},"content":"\n\nnres = 6  # number of grid points per wavelength in material (not vacuum)\n\nlx = w_wg + 2 * lateral_port_margin\nly = d + 2 * height_port_margin\nmodes = [\n    lumi.Mode(\n        ports=[\"o1\", \"o2\"],\n        wavelengths=lumi.chebyshev_nodes(wavelengths[0], wavelengths[-1],7),\n        start=[-lx / 2, -height_port_margin],  # local xy frame, local y=0 at global zmin of port layer\n        stop=[lx / 2, d + height_port_margin],\n    )\n]\n\nmaterial_library = {\n    \"Si\": lumi.Material(\n        epsilon=12.25,\n        # sigma=0.001,\n        # chi2=0.001,\n        # chi3=0.001,\n        # dispersion=[(0.001, 0.001, True)],\n    ),\n    \"SiO2\": lumi.Material(epsilon=2.25),\n}\nmaterial_library[\"background\"] = material_library[\"SiO2\"]  # set background material\n\nlayer_stack = LayerStack(\n    layers={\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=d,\n            zmin=0.0,\n            material=\"Si\",\n            mesh_order=1,\n        ),\n    }\n)\n\nsources = [\n    lumi.Source(\n        \"o1\",\n        wavelength=wavelength,\n        source_port_margin=source_port_margin,\n        bandwidth=0.2,\n    )\n]\n\nlumi.make(\n    path=path,  \n    name=name,\n    component=c,\n    modes=modes,\n    wavelengths=wavelengths,\n    sources=sources,  # launch into port \"1\"\n    #\n    zmin=-zmargin,\n    zmax=d + zmargin,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    gpu=\"CUDA\",  # use GPU acceleration\n    nres=nres,\n    field_decay_threshold=0.0001,  # field decay threshold for stopping simulation\n    relative_pml_depths=[1, 1, 0.3],  # relative PML thes in x, y, z\n    relative_courant=0.9,\n    saveat=10,\n)\n\n\n\n\n\n\n\nlumi.solve(path)\n\n\n\n","type":"content","url":"/test-bend#solve","position":5},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Visualize"},"type":"lvl2","url":"/test-bend#visualize","position":6},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Visualize"},"content":"\n\nviews=[lumi.View(\"Hz\")]\nlumi.peek(path,views)\n\n\n\n\n\n\n\nlumi.movie(path,views)\n\n\n\n\n\n","type":"content","url":"/test-bend#visualize","position":7},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Results"},"type":"lvl2","url":"/test-bend#results","position":8},{"hierarchy":{"lvl1":"Photonic waveguide bend","lvl2":"Results"},"content":"\n\nplt.close()\nsol = lumi.load(path)\nx = wavelengths\n\ny = lumi.query(sol, \"To2@0,o1@0\")  # wavelength or frequency ordered depending on problem setup\ny = lumi.query(sol, \"T2,1\")\n# y=np.abs2(sol['waves']['o3@0']/sol['waves']['o1@0'])\n\n# y=[10*np.log10(y) for y in y]\n\nplt.plot(x, y)\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"T21 power transmission\")\nplt.show()\n\n\n\n","type":"content","url":"/test-bend#results","position":9},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch"},"type":"lvl1","url":"/test-patch","position":0},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch"},"content":"We simulate a narrowband patch antenna fed by a microstrip line around 1.5 GHz. Compare with \n\nCOMSOL example.\n\n# render movie\n\n\n\n","type":"content","url":"/test-patch","position":1},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Geometry"},"type":"lvl2","url":"/test-patch#geometry","position":2},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# simulation folder\nname = \"microstrip_patch_antenna\"\npath = os.path.join(\"runs\", name)\n\n# length and frequency units are arbitrary but must be consistent. Here we use mm and GHz.\nfrequency = 1.55  # characteristic frequency in GHz\nfrequencies = np.linspace(1.45, 1.65, 101).tolist()\nwl1f = 300  # vacuum wavelength at 1 unit of frequency in your units\nwavelength = wl1f / frequency  # characteristic wavelength\n\n# microstrip patch [mm]\nd = 1.524 # sub depth\nw_line = 3.2 # 50 ohm line width\nw_patch = 53 # Patch width\nl_patch = 52 # Patch length\nw_slot = 7 # slot width\nl_flap = 15.5 # flap or slot length\nw_flap=w_patch/2-w_slot-w_line/2\nw_sub = 200 # sub width\nl_sub = 200 # sub length\nth=.1 # metal thickness\n\nlateral_port_margin = height_port_margin = 2*d\nsource_port_margin =  1.5*(w_line+2*lateral_port_margin)\nlx_mode = w_line + 2 * lateral_port_margin\nly_mode = th + height_port_margin + d\n\n# layers\nWG = 1, 0\nPATCH = 2, 0\nSUB= 3, 0\n\n# make geometry in gdsfadory\n# alternatively can import .gds into gdsfadory\n\nc = gf.Component()\n\nc.add_polygon(\n    [\n        (-l_patch / 2, -w_patch / 2),\n        (-l_patch / 2 + l_flap, -w_patch / 2),\n        (-l_patch / 2 + l_flap, -w_patch / 2 + w_flap),\n        (-l_patch / 2, -w_patch / 2 + w_flap),\n    ],\n    layer=PATCH,\n)\nc.add_polygon(\n    [\n        (-l_patch / 2, w_patch / 2),\n        (-l_patch / 2 + l_flap, w_patch / 2),\n        (-l_patch / 2 + l_flap, w_patch / 2 - w_flap),\n        (-l_patch / 2, w_patch / 2 - w_flap),\n    ],\n    layer=PATCH,\n)\nc.add_polygon(\n    [\n        (l_patch / 2, -w_patch / 2),\n        (-l_patch / 2 + l_flap, -w_patch / 2),\n        (-l_patch / 2 + l_flap, w_patch / 2),\n        (l_patch / 2, w_patch / 2),\n    ],\n    layer=PATCH,\n)\n\nc.add_polygon(\n    [\n        (-l_sub / 2, -w_sub / 2),\n        (-l_sub / 2, w_sub / 2),\n        (l_sub / 2, w_sub / 2),\n        (l_sub / 2, -w_sub / 2),\n    ],\n    layer=SUB,\n)\n\nline = c << gf.components.straight((l_sub - l_patch) / 2 + l_flap, width=w_line)\nline.movex(-l_sub / 2)\nc.add_port(\n    f\"o1\", center=(-l_patch / 2, 0), width=w_line, orientation=180, layer=WG\n)\n\nc.plot()\n\n\n\n","type":"content","url":"/test-patch#geometry","position":3},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Solve"},"type":"lvl2","url":"/test-patch#solve","position":4},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Solve"},"content":"\n\n# adaptive meshing\nnres = 16 # points per wavelength in material\ndx0 = wavelength / nres  # mesh step in air\n\nlayer_stack = LayerStack(\n    layers={\n        \"patch\": LayerLevel(\n            layer=LogicalLayer(layer=PATCH),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=1,\n        ),\n        \"line\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            zmin=0,\n            thickness=th,\n            material=\"PEC_line\",\n            mesh_order=2,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=SUB),\n            zmin=-d,\n            thickness=d,\n            material=\"sub\",\n            mesh_order=3,\n        ),\n    }\n)\n\ndx_line = w_line / 6  # 6 mesh points across the strip\ndx_patch = l_patch / 20  # 20 mesh points across the patch\n\neps_sub = 3.38\nn_sub = np.sqrt(eps_sub)\n\nmaterial_library = {\n    \"air\": lumi.Material(),\n    \"sub\": lumi.Material(epsilon=eps_sub),\n    \"PEC\": lumi.PECMaterial(mesh_density=dx0/dx_patch),\n    \"PEC_line\": lumi.PECMaterial(mesh_density=[n_sub, dx0/dx_line,1]),\n    'background': lumi.Material(),\n}\n\n# radiation port\nR=H = (w_sub) / 2\nangres=np.deg2rad(5)\nθmax=np.deg2rad(80) # avoid microstrip\nφmax=np.deg2rad(360)\nports = [\n    lumi.SpherePort(\n        name=\"o2\",\n        origin=(0, 0, 0),\n        radius=R,\n        angres=angres,\n        θmax=θmax,\n        φmax=φmax,\n    ),\n]\n\n# microstrip mode\n_dx = dx_line\n_dy = th\nmodes = [\n    lumi.Mode(\n        ports=[\"o1\"],\n        frequencies=lumi.chebyshev_nodes(frequencies[1], frequencies[-1], 5),\n        metallic_boundaries=[\"y-\", \"line\"],\n        nmodes=1,\n        start=[-lx_mode / 2, -d,],  # local xy frame, local y=0 at global zmin of port layer\n        stop=[lx_mode / 2, th + height_port_margin],\n        voltage_line=[(0, -d), (0, 0)],  # optional\n        current_loop=[\n            (-w_line / 2 - _dx, -_dy),\n            (-w_line / 2 - _dx, th + _dy),\n            (w_line / 2 + _dx, th + _dy),\n            (w_line / 2 + _dx, -_dy),\n        ],  # optional\n    )\n]\n\nsources = [\n    lumi.Source(\n        \"o1\", frequency=frequency, duration=1, source_port_margin=source_port_margin\n    ) # modulated Gaussian pulse\n]\n\n\nlumi.make(\n    path=path,  # path to make problem folder\n    name=name,\n    component=c,\n    frequencies=frequencies,\n    frequency=frequency,\n    wl1f=wl1f,\n    boundaries=[\"PML\", \"PML\", [\"PEC\", \"PML\"]],\n    #\n    ports=ports,\n    modes=modes,\n    sources=sources,\n    #\n    zmin=-d,\n    zmax=H,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    #\n    gpu=\"CUDA\",\n    nres=nres,  # number of grid points per wavelength in material (not vacuum)\n    relative_courant=0.9,\n    field_decay_threshold=.001,  # stop when energy have decayed to this fraction of peak\n    saveat=.5,  # save frame every _ periods for plotting movie\n)\nlumi.solve(path)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/test-patch#solve","position":5},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Visualize"},"type":"lvl2","url":"/test-patch#visualize","position":6},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Visualize"},"content":"\n\nmaterial_color_map={\n        'background':'transparent',\n        'sub':('yellow',.5),\n        'PEC':('black',.5), # (color, alpha)\n}\nviews=[\n        lumi.View(\"Ex\", z=th / 2,  field_color_intensity=10,material_color_map=material_color_map,material_library=material_library),\n        # lumi.View(\"Ez\", z=-d / 2,  field_color_intensity=10,material_color_map=material_color_map,material_library=material_library),\n    ]\nlumi.peek(path, views) # snapshots at halfway and final time step\n\n\n\nlumi.movie(path, views) # full movie - this may take a while to render\n\n\n\n\n\n","type":"content","url":"/test-patch#visualize","position":7},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Analysis"},"type":"lvl2","url":"/test-patch#analysis","position":8},{"hierarchy":{"lvl1":"RF antenna: microstrip fed patch","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\n\n# S11 plot\nfig = plt.figure()\nx = frequencies\ny = [10 * np.log10(v) for v in lumi.query(sol, \"T1,1\")]\n# y = [10 * math.log10(v) for v in lumi.query(sol, \"To2@0,o1@0\")]\n\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S11 [dB]\")\nplt.show()\n\nflux = sol[\"dBi\"][\"o2\"] # can append after o2 @H, V, L or R for polarization\ni = np.argmin(y)\nnφ = round(φmax / angres) + 1\nnθ = round(θmax / angres) + 1\nθ = np.linspace(0, θmax, nθ)\n\n# Radiation pattern plots\nflux_E_plane1 = flux[:, 0, i]\nflux_E_plane2 = flux[:, round((nφ - 1) / 2), i]\n\nflux_H_plane1 = flux[:, round((nφ - 1) / 4), i]\nflux_H_plane2 = flux[:, round((nφ - 1) / 4 * 3), i]\n\nfig = plt.figure()\n\nax = fig.add_subplot(121, polar=True)\nax.set_theta_zero_location(\"N\")\nax.set_theta_direction(\"clockwise\")\nax.plot(θ, flux_E_plane1)\nax.plot(-θ, flux_E_plane2)\nax.set_title(\"E-Plane Radiation Pattern\")\nax.set_ylim(-30, 30)\n\nax = fig.add_subplot(122, polar=True)\nax.set_theta_zero_location(\"N\")\nax.set_theta_direction(\"clockwise\")\nax.plot(θ, flux_H_plane1)\nax.plot(-θ, flux_H_plane2)\nax.set_ylim(-30, 30)\nax.set_title(\"H-Plane Radiation Pattern\")\n\n\n\n\n\n\n\ny=Z0 = 377 * sol[\"Z\"][\"o1\"]\nplt.plot(x, np.real(y), label=\"Real\", color=\"orange\")\nplt.plot(x, np.imag(y), label=\"Imaginary\", color=\"blue\")\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"complex line impedance [Ohms]\")\nplt.legend()\nplt.show()\n\n\n\nS11=sol['waves']['o1@0+']/sol['waves']['o1@0-']\ny=Za=Z0*(1+S11)/(1-S11)\n\nplt.plot(x, np.real(y), label=\"Real\", color=\"orange\")\nplt.plot(x, np.imag(y), label=\"Imaginary\", color=\"blue\")\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"antenna impedance [Ohms]\")\nplt.legend()\nplt.show()\n\n","type":"content","url":"/test-patch#analysis","position":9},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"type":"lvl1","url":"/test-ring","position":0},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator"},"content":"","type":"content","url":"/test-ring","position":1},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"type":"lvl2","url":"/test-ring#overview","position":2},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Overview"},"content":"We simulate small silicon ring resonator coupled to parallel waveguides buried in silica cladding. Compare with \n\nLumerical example\n\n","type":"content","url":"/test-ring#overview","position":3},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"type":"lvl2","url":"/test-ring#geometry","position":4},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport numpy as np\nimport os\nimport math\nimport matplotlib.pyplot as plt\n\n# simulation folder\nname='photonic_ring_resonator'\npath = os.path.join(\"runs\", name)\n\n# length units are arbitrary so long as they are consistent, in this case [um]. everything gets normalized around origin wavelength and period at backend.\nwavelength = 1.55  # characteristic wavelength [um]\nbandwidth = 0.1  # wavelength bandwidth [um]\nwavelengths = np.linspace(wavelength - bandwidth / 2, wavelength + bandwidth / 2, 401)\n\nr = 3.1  # radius of ring\nw_wg = 0.4  # width of waveguide\ngap = 0.1  # gap between waveguide and ring\nth = 0.18  # th of waveguide\n\n# gds layers\nWG = (1, 0)  # waveguide layer\nBBOX = (10, 0)  # bounding box layer\n\n# we create geometry in gdsfactory. alternatively, you can import .gds layout into gdsfactory or .stl bodies directly into ours\n\n# margins\nheight_port_margin = lateral_port_margin = 0.8\nmargin = 1.25 * lateral_port_margin\nzmargin = 1.25 * height_port_margin\nsource_port_margin = 1.0 * (w_wg + 2 * lateral_port_margin)\n\n# draw layout in gdsfactory. `gf.components` defaults to layer WG = (1, 0)\nc = gf.Component()\n\ndut = c << gf.components.ring(radius=r, width=w_wg, layer=WG)\n\nl_branch = 2 * r + w_wg + source_port_margin + 2*margin\nxoffset = -source_port_margin - margin - r - w_wg / 2\nyoffset = w_wg + gap + r\nbranch_top = c << gf.components.straight(length=l_branch, width=w_wg)\nbranch_top.move((xoffset, w_wg + gap + r))\n\nbranch_bottom_left = c << gf.components.straight(length=source_port_margin, width=w_wg)\nbranch_bottom_left.move((xoffset, -yoffset))\n\nbranch_bottom_right = c << gf.components.straight(length=l_branch - source_port_margin, width=w_wg)\nbranch_bottom_right.connect(\"o1\", branch_bottom_left.ports[\"o2\"])\n\n\n# add ports\nc.add_port(\"o1\", port=branch_bottom_right.ports[\"o1\"])\nc.add_port(\"o2\", port=branch_bottom_right.ports[\"o2\"])  # thru channel\nc.add_port(\"o3\", port=branch_top.ports[\"o1\"])  # drop channel\n\nc << gf.components.bbox(component=c, layer=BBOX, top=margin, bottom=margin)\nc.plot()\n\n\n\n","type":"content","url":"/test-ring#geometry","position":5},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"type":"lvl2","url":"/test-ring#solve","position":6},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Solve"},"content":"\n\n# for gdsfactory, we need vertical layer stack. \"core\" layer is special as `height_port_margin` are demarcated from it for defining modal sources and monitors. during 3d meshing lower mesh order layers supplant higher mesh order layers\nlayer_stack = LayerStack(\n    layers={\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=WG),\n            thickness=th,\n            zmin=0.0,\n            material=\"Si\",\n            mesh_order=10,\n        ),\n    }\n)\n\n# our default lumi.MATERIAL_LIBRARY lib covers limited range of photonic and PCB material_library. here we create our own material_library. `background` is special and tags regions outside any bodies during meshing\nmaterial_library = {\n    \"Si\": lumi.Material(epsilon=12.25),\n    \"SiO2\": lumi.Material(epsilon=2.25),\n}\nmaterial_library[\"background\"] = material_library[\n    \"SiO2\"\n]  \n\n# source launches `source_port_margin` in front of port. it's bidirectional: the other direction goes into PML. pulse spectrum rolls off gradually past bandwidth limits.\nsources = [\n    lumi.Source(\n        \"o1\",\n        source_port_margin=source_port_margin,\n        wavelength=wavelength,\n        bandwidth=wavelength/5,\n        modenums=[0],  # fundamental mode only\n    )\n]\n\nlx=w_wg + 2 * lateral_port_margin\nly=th + 2 * height_port_margin\nmodes = [lumi.Mode(\n    ports=[f'o{i}' for i in [1, 2, 3]], # ports that this mode applies to\n    wavelengths=lumi.chebyshev_nodes(wavelengths[0], wavelengths[-1]),\n    start=[-lx/2, -height_port_margin], # local xy frame, local y=0 at global zmin of port layer\n    stop=[lx/2, th + height_port_margin],\n    )]\n\nlumi.make(\n    path=path,\n    component=c,\n    wavelengths=wavelengths,\n    sources=sources,\n    modes=modes,\n    # limits\n    zmin=-zmargin,\n    zmax=th + zmargin,\n    # materials and layers\n    material_library=material_library,\n    layer_stack=layer_stack,\n    # accuracy and speed settings\n    gpu=\"CUDA\",  # use GPU acceleration\n    nres=8,  # number of grid points per wavelength in material (not vacuum)\n    relative_courant=0.95,  # relative to maximum theoretical Courant number at\n    relative_pml_depths=[1, 1, 0.3],  \n    Tsim=600,  # max time [periods]\n    field_decay_threshold=0.001,  # field energy decay threshold for stopping simulation\n    saveat=50,  # save and plot field every n periods\n)\n\nlumi.solve(path)\n\n\n\n\n\n\n\n","type":"content","url":"/test-ring#solve","position":7},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"type":"lvl2","url":"/test-ring#visualize","position":8},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Visualize"},"content":"\n\nviews=[lumi.View(\"Hz\", z=\"halfway\", y=0, x=0)]\nlumi.peek(path,views) # halfway and final snapshots\n\n\n\n\n\n\n\nlumi.movie(path,views) # full movie - this may take a while to generate\n# due to frame aliasing the movie may appear to show the signal going around once when in effect it goes around multiple times. To fix this, use lower `saveat`\n\n\n\n\n\n","type":"content","url":"/test-ring#visualize","position":9},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"type":"lvl2","url":"/test-ring#analysis","position":10},{"hierarchy":{"lvl1":"Photonic integrated circuit: ring resonator","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = wavelengths\n\ny = lumi.query(sol, \"To3@0,o1@0\")  # wavelength or frequency ordered depending on problem setup\n# y = lumi.query(sol, \"T3,1\") # wavelength or frequency ordered depending on problem setup\n# y=math.abs2(sol['waves']['o3@0']/sol['waves']['o1@0'])\n\nplt.plot(x, y)\nplt.xlabel(\"wavelength [um]\")\nplt.ylabel(\"drop channel transmitted power\")\nplt.show()\n\n\n\n","type":"content","url":"/test-ring#analysis","position":11},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"type":"lvl1","url":"/test-stub","position":0},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter"},"content":"","type":"content","url":"/test-stub","position":1},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"type":"lvl2","url":"/test-stub#overview","position":2},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Overview"},"content":"We simulate a quarter wave stub bandstop filter in RF microstrip with nominal 5GHz notch.\n\n# render movie\n\n\n\n","type":"content","url":"/test-stub#overview","position":3},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"type":"lvl2","url":"/test-stub#geometry","position":4},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Geometry"},"content":"\n\nimport luminescent as lumi\nfrom gdsfactory.technology import LogicalLayer, LayerLevel, LayerStack\nimport gdsfactory as gf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# simulation folder\nname='microstrip_stub_filter'\npath = os.path.join(\"runs\", name)\n\n# length and frequency units are arbitrary but must be consistent. here we use mm and GHz\nfrequency = 5  # characteristic frequency in GHz\nfrequencies = np.linspace(3, 7, 81).tolist()\nwl1f = 300  # vacuum wavelength at 1 unit of frequency, all in your units\nwavelength = wl1f / frequency  # characteristic wavelength\nbandwidth = max(frequencies) - min(frequencies)\n\n# microstrip\nw_line = 1.52  # mm\nth = 0.035  # mm\nd = 0.8  # mm\nc = 87.5 / 139  # relative signal speed, from microstrip calculator\n\nwl_sig = wl1f * c / frequency  # wavelength in the signal line\nl_stub = wl_sig / 4 # quarter-wave stub length\nl_feed = 1 * l_stub\nlateral_port_margin = height_port_margin = 2 * d\nmargin = zmargin = 1.25 * lateral_port_margin\nlx_mode = w_line + 2 * lateral_port_margin  # lateral size of mode region\nsource_port_margin = 1.5 * (w_line + 2 * lateral_port_margin)\n\n# layers\nFEED = 1, 0\nSTUB = 2, 0\nSUB = 10, 0\n\n# make geometry in gdsfadory\n# alternatively can import .gds into gdsfadory\nc = gf.Component()\nfeed = c << lumi.straight(length=l_feed, width=w_line, layer=FEED)\nstub = c << lumi.straight(length=l_stub, width=w_line, layer=STUB)\nstub.rotate(90)\nstub.movex(l_feed / 2)\next = c << lumi.straight(source_port_margin, width=w_line, layer=FEED)\next.connect(\"o2\", feed.ports[\"o1\"])\n\nfor i in (1, 2):\n    c.add_port(f\"o{i}\", port=feed.ports[f\"o{i}\"])\n\nc << gf.components.bbox(component=c, layer=SUB, top=margin, bottom=margin)\nc.plot()\n\n\n\n\n\n","type":"content","url":"/test-stub#geometry","position":5},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"type":"lvl2","url":"/test-stub#solve","position":6},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Solve"},"content":"\n\n# adaptive meshing\nnres = 16\ndx0 = wavelength / nres\n\nlayer_stack = LayerStack(\n    layers={\n        \"feed\": LayerLevel(\n            layer=LogicalLayer(layer=FEED),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=10,\n        ),\n        \"stub\": LayerLevel(\n            layer=LogicalLayer(layer=STUB),\n            zmin=0,\n            thickness=th,\n            material=\"PEC\",\n            mesh_order=20,\n        ),\n        \"core\": LayerLevel(\n            layer=LogicalLayer(layer=SUB),\n            zmin=-d,\n            thickness=d,\n            material=\"sub\",\n            mesh_order=30,\n        ),\n    }\n)\n\n# materials\neps_sub = 4.3\nn_sub = np.sqrt(eps_sub)\n\ndx = w_line / 4  # 4 mesh points across the strip\nn_PEC = dx0 / (dx)  # mesh density relative to vacuum\n\nmaterial_library = {\n    \"sub\": lumi.Material(epsilon=eps_sub),\n    \"PEC\": lumi.PECMaterial(mesh_density=n_PEC),\n}\nmaterial_library[\"background\"] = lumi.Material(epsilon=1.0)\n\n_dx=dx \n_dy=th\nmodes = [\n    lumi.Mode(\n        ports=[\"o1\", \"o2\"],\n        frequencies=[frequency],\n        metallic_boundaries=[\"y-\", \"feed\"],\n        nmodes=1,\n        start=[-lx_mode/2, -d], # local xy frame, local y=0 at global zmin of port layer\n        stop=[lx_mode/2, th + height_port_margin],\n        voltage_line=[(0, -d), (0, 0)], # optional\n        current_loop=[\n            (-w_line / 2 - _dx,  - _dy),\n            (-w_line / 2 - _dx,  th + _dy),\n            (w_line / 2 + _dx,  th + _dy),\n            (w_line / 2 + _dx,  - _dy),\n        ], # optional\n    )\n]\n\nsources = [\n    lumi.Source(\n        \"o1\", frequency=frequency, duration=0.5, source_port_margin=source_port_margin\n    ) # modulated Gaussian pulse\n]\n \nlumi.make(\n    path=path,\n    component=c,\n    frequency=frequency, # characteristic frequency\n    frequencies=frequencies,\n    wl1f=wl1f,\n    boundaries=[\"PML\", \"PML\", [\"PEC\", \"PML\"]],\n    sources=sources,\n    modes=modes,\n    #\n    material_library=material_library,\n    layer_stack=layer_stack,\n    zmin=-d,\n    zmax=th + zmargin,\n    # performance\n    gpu=\"CUDA\",  # use GPU acceleration)\n    nres=nres,\n    relative_courant=0.9,  # relative courant number between 0 and 1\n    relative_pml_depths=[1, 0.3, 0.3],\n    field_decay_threshold=0.01,  # field decay threshold for stopping simulation\n    saveat=0.25,  # save frame for plotting every _ periods\n)\nlumi.solve(path)\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/test-stub#solve","position":7},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"type":"lvl2","url":"/test-stub#visualize","position":8},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Visualize"},"content":"\n\nmaterial_color_map={\n        'background':'transparent',\n        'sub':('yellow',.5),\n        'PEC':('black',.5), # (color, alpha)\n}\nviews=[\n        lumi.View(\"Ez\", x=-source_port_margin, y=0, z=-d / 2, material_color_map=material_color_map,material_library=material_library),\n        lumi.View(\"Hz\", x=-source_port_margin, y=0, z=th / 2, material_color_map=material_color_map,material_library=material_library),\n    ]\nlumi.peek(path, views) # snapshots at halfway and final time step\n\n\n\n\n\n\n\nlumi.movie(path, views) # full movie - may take a while to render\n\n\n\n\n\n","type":"content","url":"/test-stub#visualize","position":9},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"type":"lvl2","url":"/test-stub#analysis","position":10},{"hierarchy":{"lvl1":"RF microstrip: quarter wave stub filter","lvl2":"Analysis"},"content":"\n\nsol = lumi.load(path)\nx = frequencies\ny = lumi.query(sol, \"To2,o1\") # convenience function for T-parameters using modal decomposition\n\n# S-parameters can also be computed explicitly from complex valued modal or voltage waves:\n# y = np.abs2(sol[\"waves\"][\"o2@0+\"] / sol[\"waves\"][\"o1@0-\"]) # explicit T21 using forward/backward modal amplitudes\n# y = np.abs2(sol[\"waves\"][\"o2+\"] / sol[\"waves\"][\"o1-\"]) # using forward/backward voltage waves\n\ny = [10 * np.log10(v) for v in y]\nplt.plot(x, y)\nplt.xlabel(\"f [GHz]\")\nplt.ylabel(\"S21 [dB]\")\nplt.show()\n\n\n\n\n\ny=377*sol['Z']['o1']\nplt.plot(x,np.real(y),label=\"Real\",color='orange')\nplt.plot(x,np.imag(y),label=\"Imaginary\",color='blue')\nplt.xlabel(\"f [GHz]\")\nplt.ylabel('complex line impedance [Ohms]')\nplt.legend()\nplt.show()\n\n","type":"content","url":"/test-stub#analysis","position":11}]}